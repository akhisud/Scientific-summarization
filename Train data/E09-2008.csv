Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma: finite-state compiler library	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	specific support many natural language processing applications producing morphological phonological analyzers.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	1
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	compiler library implemented C API available.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	˜ $ $.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	complement, containment operators / ./.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Horizontal lines separate precedence classes.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	fact, many internally complex operations Foma built reduction type logical expressions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	void check_word(char *s) { 2.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	fsm_t *network; 3.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	fsm_match_result *result; 4.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	"5. network = fsm_regex(""a+ b+""); 6."	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	result = fsm_match(fsm, s); 7.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	(result->num_matches > 0) 8.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	"printf(""Regex matches""); 9."	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	mind, care taken attempt optimize underlying primitive algorithms.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma free software remain GNU General Public License.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	source code available, collaboration encouraged.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	first second entries short regular expressions exhibit exponential behavior.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	second results FSM 221 states 222 arcs.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	others scripts run Xerox/PARC Foma.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma: finite-state compiler library	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	specific support many natural language processing applications producing morphological phonological analyzers.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	1
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	compiler library implemented C API available.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	˜ $ $.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	complement, containment operators / ./.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Horizontal lines separate precedence classes.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	fact, many internally complex operations Foma built reduction type logical expressions.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	void check_word(char *s) { 2.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	fsm_t *network; 3.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	fsm_match_result *result; 4.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	"5. network = fsm_regex(""a+ b+""); 6."	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	result = fsm_match(fsm, s); 7.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	(result->num_matches > 0) 8.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	"printf(""Regex matches""); 9."	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	mind, care taken attempt optimize underlying primitive algorithms.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	Foma free software remain GNU General Public License.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	source code available, collaboration encouraged.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	first second entries short regular expressions exhibit exponential behavior.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	second results FSM 221 states 222 arcs.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	others scripts run Xerox/PARC Foma.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
Recently, open-source tools released: paper, used Foma (Hulden, 2009) develop Russian guesser.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma: finite-state compiler library	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	specific support many natural language processing applications producing morphological phonological analyzers.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma largely compatible Xerox/PARC finite-state toolkit.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	compiler library implemented C API available.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	˜ $ $.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	complement, containment operators / ./.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Horizontal lines separate precedence classes.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	fact, many internally complex operations Foma built reduction type logical expressions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	void check_word(char *s) { 2.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	fsm_t *network; 3.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	fsm_match_result *result; 4.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	"5. network = fsm_regex(""a+ b+""); 6."	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	result = fsm_match(fsm, s); 7.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	(result->num_matches > 0) 8.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	"printf(""Regex matches""); 9."	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	mind, care taken attempt optimize underlying primitive algorithms.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma free software remain GNU General Public License.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	source code available, collaboration encouraged.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	first second entries short regular expressions exhibit exponential behavior.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	second results FSM 221 states 222 arcs.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	others scripts run Xerox/PARC Foma.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma: finite-state compiler library	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	specific support many natural language processing applications producing morphological phonological analyzers.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma largely compatible Xerox/PARC finite-state toolkit.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	compiler library implemented C API available.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	˜ $ $.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	complement, containment operators / ./.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Horizontal lines separate precedence classes.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	fact, many internally complex operations Foma built reduction type logical expressions.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	void check_word(char *s) { 2.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	fsm_t *network; 3.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	fsm_match_result *result; 4.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	"5. network = fsm_regex(""a+ b+""); 6."	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	result = fsm_match(fsm, s); 7.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	(result->num_matches > 0) 8.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	"printf(""Regex matches""); 9."	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	mind, care taken attempt optimize underlying primitive algorithms.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	Foma free software remain GNU General Public License.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	source code available, collaboration encouraged.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	first second entries short regular expressions exhibit exponential behavior.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	second results FSM 221 states 222 arcs.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	others scripts run Xerox/PARC Foma.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
rules learned format so-called phonological replacement rules (Beesley Karttunen, 2002) later converted equivalent finite-state transducers using freely available foma toolkit (Hulden, 2009a).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma: finite-state compiler library	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	specific support many natural language processing applications producing morphological phonological analyzers.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	1
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	compiler library implemented C API available.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	˜ $ $.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	complement, containment operators / ./.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Horizontal lines separate precedence classes.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	fact, many internally complex operations Foma built reduction type logical expressions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	void check_word(char *s) { 2.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	fsm_t *network; 3.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	fsm_match_result *result; 4.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	"5. network = fsm_regex(""a+ b+""); 6."	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	result = fsm_match(fsm, s); 7.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	(result->num_matches > 0) 8.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	"printf(""Regex matches""); 9."	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	mind, care taken attempt optimize underlying primitive algorithms.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma free software remain GNU General Public License.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	source code available, collaboration encouraged.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	first second entries short regular expressions exhibit exponential behavior.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	second results FSM 221 states 222 arcs.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	others scripts run Xerox/PARC Foma.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma: finite-state compiler library	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	specific support many natural language processing applications producing morphological phonological analyzers.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	1
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	compiler library implemented C API available.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	˜ $ $.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	complement, containment operators / ./.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Horizontal lines separate precedence classes.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	fact, many internally complex operations Foma built reduction type logical expressions.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	void check_word(char *s) { 2.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	fsm_t *network; 3.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	fsm_match_result *result; 4.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	"5. network = fsm_regex(""a+ b+""); 6."	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	result = fsm_match(fsm, s); 7.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	(result->num_matches > 0) 8.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	"printf(""Regex matches""); 9."	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	mind, care taken attempt optimize underlying primitive algorithms.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	Foma free software remain GNU General Public License.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	source code available, collaboration encouraged.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	first second entries short regular expressions exhibit exponential behavior.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	second results FSM 221 states 222 arcs.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	others scripts run Xerox/PARC Foma.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
syllable counter implemented using foma software (Hulden, 2009), implementation (Hulden, 2006) found homepage Figure 1: verse written BAD web application.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma: finite-state compiler library	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	specific support many natural language processing applications producing morphological phonological analyzers.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	compiler library implemented C API available.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	˜ $ $.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	complement, containment operators / ./.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Horizontal lines separate precedence classes.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	fact, many internally complex operations Foma built reduction type logical expressions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	void check_word(char *s) { 2.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	fsm_t *network; 3.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	fsm_match_result *result; 4.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	"5. network = fsm_regex(""a+ b+""); 6."	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	result = fsm_match(fsm, s); 7.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	(result->num_matches > 0) 8.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	"printf(""Regex matches""); 9."	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	1
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	mind, care taken attempt optimize underlying primitive algorithms.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma free software remain GNU General Public License.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	source code available, collaboration encouraged.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	first second entries short regular expressions exhibit exponential behavior.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	second results FSM 221 states 222 arcs.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	others scripts run Xerox/PARC Foma.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma: finite-state compiler library	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	specific support many natural language processing applications producing morphological phonological analyzers.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	compiler library implemented C API available.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	˜ $ $.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	complement, containment operators / ./.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Horizontal lines separate precedence classes.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	fact, many internally complex operations Foma built reduction type logical expressions.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	void check_word(char *s) { 2.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	fsm_t *network; 3.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	fsm_match_result *result; 4.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	"5. network = fsm_regex(""a+ b+""); 6."	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	result = fsm_match(fsm, s); 7.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	(result->num_matches > 0) 8.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	"printf(""Regex matches""); 9."	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	1
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	mind, care taken attempt optimize underlying primitive algorithms.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	Foma free software remain GNU General Public License.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	source code available, collaboration encouraged.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	first second entries short regular expressions exhibit exponential behavior.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	second results FSM 221 states 222 arcs.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	others scripts run Xerox/PARC Foma.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
Since question transducer functionality known decidable (Blattner Head, 1977), efficient algorithm given Hulden (2009a), included foma (with command test functional) address question calculating constraint, necessary, permute violation markers transducer functional.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma: finite-state compiler library	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	specific support many natural language processing applications producing morphological phonological analyzers.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	1
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	compiler library implemented C API available.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	˜ $ $.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	complement, containment operators / ./.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Horizontal lines separate precedence classes.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	fact, many internally complex operations Foma built reduction type logical expressions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	void check_word(char *s) { 2.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	fsm_t *network; 3.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	fsm_match_result *result; 4.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	"5. network = fsm_regex(""a+ b+""); 6."	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	result = fsm_match(fsm, s); 7.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	(result->num_matches > 0) 8.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	"printf(""Regex matches""); 9."	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	mind, care taken attempt optimize underlying primitive algorithms.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma free software remain GNU General Public License.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	source code available, collaboration encouraged.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	first second entries short regular expressions exhibit exponential behavior.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	second results FSM 221 states 222 arcs.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	others scripts run Xerox/PARC Foma.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma: finite-state compiler library	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	specific support many natural language processing applications producing morphological phonological analyzers.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma largely compatible Xerox/PARC finite-state toolkit.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	1
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	compiler library implemented C API available.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	API many ways similar standard C library <regex.h>, similar calling conventions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	may useful someone wanting build separate GUI interface using existing low- level functions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	˜ $ $.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	complement, containment operators / ./.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Horizontal lines separate precedence classes.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	fact, many internally complex operations Foma built reduction type logical expressions.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	void check_word(char *s) { 2.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	fsm_t *network; 3.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	fsm_match_result *result; 4.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	"5. network = fsm_regex(""a+ b+""); 6."	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	result = fsm_match(fsm, s); 7.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	(result->num_matches > 0) 8.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	"printf(""Regex matches""); 9."	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	educational use Foma support visualization machines builds AT&T Graphviz library.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	mind, care taken attempt optimize underlying primitive algorithms.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	Foma free software remain GNU General Public License.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	source code available, collaboration encouraged.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	first second entries short regular expressions exhibit exponential behavior.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	second results FSM 221 states 222 arcs.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	others scripts run Xerox/PARC Foma.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	file lexicon.lex LEXC format English dictionary 38418 entries.	0
Foma (Hulden, 2009) freely available2 toolkit allows build parse FS automata transducers.	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma: finite-state compiler library	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	specific support many natural language processing applications producing morphological phonological analyzers.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma largely compatible Xerox/PARC finite-state toolkit.	1
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	compiler library implemented C API available.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	˜ $ $.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	complement, containment operators / ./.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Horizontal lines separate precedence classes.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	fact, many internally complex operations Foma built reduction type logical expressions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	void check_word(char *s) { 2.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	fsm_t *network; 3.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	fsm_match_result *result; 4.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	"5. network = fsm_regex(""a+ b+""); 6."	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	result = fsm_match(fsm, s); 7.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	(result->num_matches > 0) 8.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	"printf(""Regex matches""); 9."	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	mind, care taken attempt optimize underlying primitive algorithms.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma free software remain GNU General Public License.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	source code available, collaboration encouraged.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	first second entries short regular expressions exhibit exponential behavior.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	second results FSM 221 states 222 arcs.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	others scripts run Xerox/PARC Foma.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma: finite-state compiler library	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	specific support many natural language processing applications producing morphological phonological analyzers.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma largely compatible Xerox/PARC finite-state toolkit.	1
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	compiler library implemented C API available.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	˜ $ $.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	complement, containment operators / ./.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Horizontal lines separate precedence classes.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	fact, many internally complex operations Foma built reduction type logical expressions.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	void check_word(char *s) { 2.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	fsm_t *network; 3.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	fsm_match_result *result; 4.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	"5. network = fsm_regex(""a+ b+""); 6."	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	result = fsm_match(fsm, s); 7.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	(result->num_matches > 0) 8.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	"printf(""Regex matches""); 9."	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	mind, care taken attempt optimize underlying primitive algorithms.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	Foma free software remain GNU General Public License.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	source code available, collaboration encouraged.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	first second entries short regular expressions exhibit exponential behavior.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	second results FSM 221 states 222 arcs.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	others scripts run Xerox/PARC Foma.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
verb chain transfer module implemented series ordered replacement rules (Beesley Karttunen, 2003) using foma finite-state toolkit (Hulden, 2009).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma: finite-state compiler library	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	specific support many natural language processing applications producing morphological phonological analyzers.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma largely compatible Xerox/PARC finite-state toolkit.	1
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	compiler library implemented C API available.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	˜ $ $.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	complement, containment operators / ./.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Horizontal lines separate precedence classes.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	fact, many internally complex operations Foma built reduction type logical expressions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	void check_word(char *s) { 2.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	fsm_t *network; 3.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	fsm_match_result *result; 4.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	"5. network = fsm_regex(""a+ b+""); 6."	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	result = fsm_match(fsm, s); 7.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	(result->num_matches > 0) 8.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	"printf(""Regex matches""); 9."	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	mind, care taken attempt optimize underlying primitive algorithms.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma free software remain GNU General Public License.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	source code available, collaboration encouraged.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	first second entries short regular expressions exhibit exponential behavior.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	second results FSM 221 states 222 arcs.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	others scripts run Xerox/PARC Foma.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma: finite-state compiler library	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	specific support many natural language processing applications producing morphological phonological analyzers.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma largely compatible Xerox/PARC finite-state toolkit.	1
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	compiler library implemented C API available.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	˜ $ $.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	complement, containment operators / ./.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Horizontal lines separate precedence classes.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	fact, many internally complex operations Foma built reduction type logical expressions.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	void check_word(char *s) { 2.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	fsm_t *network; 3.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	fsm_match_result *result; 4.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	"5. network = fsm_regex(""a+ b+""); 6."	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	result = fsm_match(fsm, s); 7.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	(result->num_matches > 0) 8.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	"printf(""Regex matches""); 9."	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	mind, care taken attempt optimize underlying primitive algorithms.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	Foma free software remain GNU General Public License.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	source code available, collaboration encouraged.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	first second entries short regular expressions exhibit exponential behavior.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	second results FSM 221 states 222 arcs.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	others scripts run Xerox/PARC Foma.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
work presented here, reimplemented expanded original rules written XFST foma2 toolkit (Hulden, 2009).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma: finite-state compiler library	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	specific support many natural language processing applications producing morphological phonological analyzers.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma largely compatible Xerox/PARC finite-state toolkit.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	compiler library implemented C API available.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	1
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	˜ $ $.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	complement, containment operators / ./.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Horizontal lines separate precedence classes.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	fact, many internally complex operations Foma built reduction type logical expressions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	void check_word(char *s) { 2.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	fsm_t *network; 3.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	fsm_match_result *result; 4.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	"5. network = fsm_regex(""a+ b+""); 6."	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	result = fsm_match(fsm, s); 7.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	(result->num_matches > 0) 8.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	"printf(""Regex matches""); 9."	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	mind, care taken attempt optimize underlying primitive algorithms.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma free software remain GNU General Public License.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	source code available, collaboration encouraged.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	first second entries short regular expressions exhibit exponential behavior.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	second results FSM 221 states 222 arcs.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	others scripts run Xerox/PARC Foma.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma: finite-state compiler library	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma compiler, programming language, C library constructing finite-state automata transducers various uses.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	specific support many natural language processing applications producing morphological phonological analyzers.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma largely compatible Xerox/PARC finite-state toolkit.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	also embraces Unicode fully supports various different formats specifying regular expressions: Xerox/PARC format, Perl-like format, mathematical format takes advantage ‘Mathematical Operators’ Unicode block.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma finite-state compiler, programming language, regular expression/finite-state library designed multipurpose use explicit support automata theoretic research, constructing lexical analyzers programming languages, building morphological/phonological analyzers, well spellchecking applications.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	compiler allows users specify finite-state automata transducers incrementally similar fashion AT&T’s fsm (Mohri et al., 1997) Lextools (Sproat, 2003), Xerox/PARC finite- state toolkit (Beesley Karttunen, 2003) SFST toolkit (Schmid, 2005).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	One Foma’s design goals compatibility Xerox/PARC toolkit.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Another goal allow ability work n-tape automata formalism expressing first-order logical constraints regular languages n-tape- transductions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma licensed GNU general public license: keeping traditions free software, distribution includes source code comes user manual library examples.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	compiler library implemented C API available.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	API many ways similar standard C library <regex.h>, similar calling conventions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	However, low-level functions operate directly automata/transducers also available (some 50+ functions), including regular expression primitives extended functions well automata deter- minization minimization algorithms.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	may useful someone wanting build separate GUI interface using existing low- level functions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	API also contains, mainly spell-checking purposes, functionality finding words match closely (but exactly) path automaton.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	makes straightforward build spell-checkers morphological transducers simply extracting range transduction matching words approximately.	1
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Unicode (UTF8) fully supported fact encoding accepted Foma.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	successfully compiled Linux, Mac OS X, Win32 operating systems, likely portable systems without much effort.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Retaining backwards compatibility Xerox/PARC time extending formalism means one often able construct finite-state networks equivalent various ways, either ASCII-based operators Unicode-based extensions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	example, one either say: ContainsX = Σ* X Σ*; MyWords = {cat}|{dog}|{mouse}; MyRule = n -> || p; ShortWords = [MyLex1]1 ∩ Σˆ<6; or: Proceedings EACL 2009 Demonstrations Session, pages 29–32, Athens, Greece, 3 April 2009.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Qc 2009 Association Computational Linguistics Operators Compatibility variant Function [ ] () [ ] () grouping parentheses, optionality ∀ ∃ N/A quantifiers \ ‘ term negation, substitution/homomorphism : : cross-product + ∗ + ∗ Kleene closures ˆ<n ˆ>n ˆ{m,n} ˆ<n ˆ>n ˆ{m,n} iterations 1 2 .1 .2 .u .l domain & range .f N/A eliminate unification flags $ $.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	˜ $ $.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	complement, containment operators / ./.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	N/A N/A ‘ignores’, left quotient, right quotient, ‘inside’ quotient ∈ ∈/ = /= N/A language membership, position equivalence ≺ < > precedes, follows ∨ ∪ ∧ ∩ - .P. .p. | & − .P. .p. union, intersection, set minus, priority unions => -> (->) @-> => -> (->) @-> context restriction, replacement rules <> shuffle (asynchronous product) × ◦ .x. .o. cross-product, composition Table 1: regular expressions available Foma highest lower precedence.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Horizontal lines separate precedence classes.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	define ContainsX ?* X ?*; define MyWords {cat}|{dog}|{mouse}; define MyRule n -> || _ p; define ShortWords Mylex.i.l & ?ˆ<6; addition basic regular expression operators shown table 1, formalism extended various ways.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	One extension ability use form first-order logic make existential statements languages transductions (Hulden, 2008).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	instance, suppose defined arbitrary regular language L, want define language contains one factor L, by: OneL = (∃x)(x ∈ L ∧ (∃y)(y ∈ L ∧ (x = y))); Here, quantifiers apply substrings, attribute usual meaning ∈ ∧, kind concatenative meaning predicate S(t1, t2).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Hence, example, OneL defines language exists string x x member language L exist string y, also L, would occur different position x. kind logical specification regular languages useful building languages would quite cumbersome express regular expression operators.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	fact, many internally complex operations Foma built reduction type logical expressions.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	mentioned, Foma supports reading writing LEXC file format, morphological categories divided so-called continuation classes.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	practice stems back earliest two-level compilers (Karttunen et al., 1987).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	simple example format: Multichar_Symbols +Pl +Sing LEXICON Root Nouns; LEXICON Nouns cat Plural; church Plural; LEXICON Plural +Pl:%ˆs #; +Sing #;	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma API gives access basic functions, constructing finite-state machine regular expression provided string, performing transduction, exhaustively matching given string starting every position.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	following basic snippet illustrates use C API instead main interface Foma construct finite-state machine encoding language a+b+ check whether string matches it: 1.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	void check_word(char *s) { 2.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	fsm_t *network; 3.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	fsm_match_result *result; 4.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	"5. network = fsm_regex(""a+ b+""); 6."	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	result = fsm_match(fsm, s); 7.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	(result->num_matches > 0) 8.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	"printf(""Regex matches""); 9."	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	"10 } Here, instead calling fsm regex() function construct machine regular expressions, could instead accessed beforementioned low-level routines built network entirely without regular expressions combining low-level primitives, follows, replacing line 5 above: network = fsm_concat( fsm_kleene_plus( fsm_symbol(""a"")), fsm_kleene_plus( fsm_symbol(""b""))); API currently active development future functionality likely include conversion networks 8-bit letter transducers/automata maximum speed regular expression matching transduction."	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	educational use Foma support visualization machines builds AT&T Graphviz library.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	educational purposes illustrate automata construction methods, support changing behavior algorithms.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	instance, default, efficiency reasons, Foma determinizes minimizes automata nearly every incremental operation.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Operations unions automata also constructed default product construction method directly produces deterministic automata.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	However, on-the-fly minimization determinization relaxed, Thompson construction method chosen interface automata remain non-deterministic non- minimized whenever possible—non-deterministic automata naturally easier inspect analyze.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Though main concern Foma efficiency, compatibility extendibility, usefulness perspective important avoid bottlenecks underlying algorithms cause compilation times skyrocket, especially constructing combining large lexical transducers.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	mind, care taken attempt optimize underlying primitive algorithms.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Table 2 shows comparison existing toolkits build deterministic, minimized automata/transducers.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	One whole, Foma seems perform particularly well pathological cases involve exponential growth number states determinizing non- deterministic machines.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	general usage patterns, advantage quite dramatic, average use Foma seems perform comparably e.g. Xerox/PARC toolkit, perhaps exception certain types large lexicon descriptions (>100,000 words).	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma project multipurpose multi-mode finite-state compiler geared toward practical construction large-scale finite-state machines may needed natural language processing well providing framework research finite-state automata.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Several wide- coverage morphological analyzers specified LEXC/xfst format compiled successfully Foma.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	Foma free software remain GNU General Public License.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	source code available, collaboration encouraged.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	GNU AT&T Foma xfst flex fsm 4 Σ∗aΣ15 0.216s 16.23s 17.17s 1.884s Σ∗aΣ20 8.605s nf nf 153.7s North Sami 14.23s 4.264s N/A N/A 8queens 0.188s 1.200s N/A N/A sudoku2x3 5.040s 5.232s N/A N/A lexicon.lex 1.224s 1.428s N/A N/A 3sat30 0.572s 0.648s N/A N/A Table 2: relative comparison running selection regular expressions scripts finite-state toolkits.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	first second entries short regular expressions exhibit exponential behavior.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	second results FSM 221 states 222 arcs.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	others scripts run Xerox/PARC Foma.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	file lexicon.lex LEXC format English dictionary 38418 entries.	0
used spell checking applications, example, integrating lexicon weighted transduc ers reflecting frequency information error models (Hulden, 2009a; Pirinen et al., 2010).	North Sami large lexicon (lexc file) North Sami language available http://divvun.no.	0
