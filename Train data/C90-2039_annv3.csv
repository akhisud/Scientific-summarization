improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Strategic Lazy Incremental Copy Graph Unification	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example, spoken Present.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	methods uses rooted directed graphs (DGs) represent FSs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	methods take two DGs inputs give unification result DG.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Previous research identified DG copying significant overhead.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Ile proposed incremental copy graph unification method avoid copying early copying.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	itowever, problem method unitication result graph consists newly created structures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Copying sharable parts called redundant copying.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	better method would nfinimize copying sharable varts.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	redundantly copied parts relatively large input graphs common feature paths.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	natural language processing, cases ubiquitous.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	I)eveloping method avoids memory wastage important.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Pereira's structure sharing FS unification method avoid problem.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	3'he skeleton part shared one input FSs result FS.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	However, advantages describing rules disadvantages applying tt~e lack control information.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	impossible straightforward unification-based formalisms.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	system advantage processing efficiency disadvantage lacking multidirectionality.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	paper, efficiency procedure- based system introduced FS unification-based system.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Section 2 explains typed feature structures (TFSs) unification them.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	section also introduces key idea EFF strategy wlfich comes observations method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Section 3 4 introduce LING method SING method, respectively.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Complex FSs complex FSs feature values share certain values among features.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	properties enable flexible descriptions.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example type symbol lattice shown Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	1.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	extended complex FS represented type symbol set feature-value pairs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Extended complex FSs called typed feature structures (TFSs).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	2.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unification example shown Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	3.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	TFSs convenient describing linguistic information unlfication-based formalisms.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	4.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	process finishes, COPY slot values ignored thus original structures destroyed.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unification procedure based method takes input two nodes roots DGs unified.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Next, procedure calculates meet type symbol.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	output node created neither input node current; otherwise output node existing current node.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Next, procedure treats arcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	arguments gives one list arcs whose labels unique one input list.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unification procedure first treats arc pairs obtained SharedArcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Next, procedure treats arcs obtained ComplementArcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	arc value copied arc label copied value added output node.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example, consider case feature first treated root nodes G1 G2 Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	5.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unification procedure applied recursively feature values input nodes.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	whole subgraph rooted 6 l/<a c> copied.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	subgraphs modified later.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	node2 = Dereferencelnode2).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Eq?(nodel, node2) Return(node1).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE outnode = GetOutNode(nodel, node2, meet).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE AddArc(outnode, sharedl.label, arcnode).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	AddArc(outnode, complement.label, newnode).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Return(outnode).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	order related unification failure tendency.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Unification fails treating arcs common labels often treating arcs unique labels.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	order strategy generalized EFF applied ordering arcs common labels.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Section 5, method uses generalized strategy proposed.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	5 due change node G3/<a c g>).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	achieve this, I, LING unification method, uses copy dependency information, developed.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	slot pairs consisting nodes arcs value.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	6).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	substitutes arcs newly copied nodes existing arcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	efficiency LING unification method depends proportion newly created structures unification result structures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Current?(node) Return(node).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	node.copy = newnode.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE AddArc(newnode, arc.label, arc.value).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDIF Returo(newnode).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Return(Nil_).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	newarcs = {newarc} U newarcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDIF Return(newarcs).	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	However, two cases rare.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Usually, number features two input structures relatively small sizes two input structures often different.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	SING unification method uses failure tendency infornmtion.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	unification failure tendencies depend systems analysis systems generation systems.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Unlike analysis case, unification features semantic representations tends fail.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	method, theretbre, failure tendency information acquired learning process.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	type symbol 'rFS represents salient information whole TFS.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	achieved sorting procedure common label arc pairs attached meet type symbol.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	However, cases occur practice.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	cases, SING unification method obtains efl]ciency gains.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Structure sharing avoids memory wastage'.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	reduces repeated calculation substructures.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	SING unification method introduces concept feature unification strategy.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	'the method treats features tending fail unification first.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
improvement simple destructive unification, Tomabechi&apos;s approach still suffers Kogure (Kogure, 1990) calls redundant copying.	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Strategic Lazy Incremental Copy Graph Unification	1
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example, spoken Present.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	methods uses rooted directed graphs (DGs) represent FSs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	methods take two DGs inputs give unification result DG.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Previous research identified DG copying significant overhead.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Ile proposed incremental copy graph unification method avoid copying early copying.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	itowever, problem method unitication result graph consists newly created structures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Copying sharable parts called redundant copying.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	better method would nfinimize copying sharable varts.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	redundantly copied parts relatively large input graphs common feature paths.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	natural language processing, cases ubiquitous.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	I)eveloping method avoids memory wastage important.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Pereira's structure sharing FS unification method avoid problem.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	3'he skeleton part shared one input FSs result FS.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	However, advantages describing rules disadvantages applying tt~e lack control information.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	impossible straightforward unification-based formalisms.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	system advantage processing efficiency disadvantage lacking multidirectionality.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	paper, efficiency procedure- based system introduced FS unification-based system.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Section 2 explains typed feature structures (TFSs) unification them.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	section also introduces key idea EFF strategy wlfich comes observations method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Section 3 4 introduce LING method SING method, respectively.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Complex FSs complex FSs feature values share certain values among features.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	properties enable flexible descriptions.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example type symbol lattice shown Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	1.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	extended complex FS represented type symbol set feature-value pairs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Extended complex FSs called typed feature structures (TFSs).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	2.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unification example shown Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	3.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	TFSs convenient describing linguistic information unlfication-based formalisms.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	4.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	process finishes, COPY slot values ignored thus original structures destroyed.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unification procedure based method takes input two nodes roots DGs unified.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Next, procedure calculates meet type symbol.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	output node created neither input node current; otherwise output node existing current node.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Next, procedure treats arcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	arguments gives one list arcs whose labels unique one input list.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unification procedure first treats arc pairs obtained SharedArcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Next, procedure treats arcs obtained ComplementArcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	arc value copied arc label copied value added output node.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example, consider case feature first treated root nodes G1 G2 Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	5.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unification procedure applied recursively feature values input nodes.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	whole subgraph rooted 6 l/<a c> copied.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	subgraphs modified later.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	node2 = Dereferencelnode2).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Eq?(nodel, node2) Return(node1).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE outnode = GetOutNode(nodel, node2, meet).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE AddArc(outnode, sharedl.label, arcnode).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	AddArc(outnode, complement.label, newnode).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Return(outnode).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	order related unification failure tendency.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Unification fails treating arcs common labels often treating arcs unique labels.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	order strategy generalized EFF applied ordering arcs common labels.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Section 5, method uses generalized strategy proposed.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	5 due change node G3/<a c g>).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	achieve this, I, LING unification method, uses copy dependency information, developed.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	slot pairs consisting nodes arcs value.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	6).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	substitutes arcs newly copied nodes existing arcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	efficiency LING unification method depends proportion newly created structures unification result structures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Current?(node) Return(node).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	node.copy = newnode.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE AddArc(newnode, arc.label, arc.value).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDIF Returo(newnode).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Return(Nil_).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	newarcs = {newarc} U newarcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDIF Return(newarcs).	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	However, two cases rare.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Usually, number features two input structures relatively small sizes two input structures often different.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	SING unification method uses failure tendency infornmtion.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	unification failure tendencies depend systems analysis systems generation systems.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Unlike analysis case, unification features semantic representations tends fail.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	method, theretbre, failure tendency information acquired learning process.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	type symbol 'rFS represents salient information whole TFS.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	achieved sorting procedure common label arc pairs attached meet type symbol.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	However, cases occur practice.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	cases, SING unification method obtains efl]ciency gains.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Structure sharing avoids memory wastage'.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	reduces repeated calculation substructures.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	SING unification method introduces concept feature unification strategy.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	'the method treats features tending fail unification first.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
extension classified class (1) above.Based paper's formalization, unification algorithms developed using graph unification techniques[23, 16].	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Strategic Lazy Incremental Copy Graph Unification	1
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example, spoken Present.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	methods uses rooted directed graphs (DGs) represent FSs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	methods take two DGs inputs give unification result DG.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Previous research identified DG copying significant overhead.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Ile proposed incremental copy graph unification method avoid copying early copying.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	itowever, problem method unitication result graph consists newly created structures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Copying sharable parts called redundant copying.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	better method would nfinimize copying sharable varts.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	redundantly copied parts relatively large input graphs common feature paths.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	natural language processing, cases ubiquitous.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	I)eveloping method avoids memory wastage important.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Pereira's structure sharing FS unification method avoid problem.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	3'he skeleton part shared one input FSs result FS.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	However, advantages describing rules disadvantages applying tt~e lack control information.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	impossible straightforward unification-based formalisms.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	system advantage processing efficiency disadvantage lacking multidirectionality.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	paper, efficiency procedure- based system introduced FS unification-based system.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Section 2 explains typed feature structures (TFSs) unification them.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	section also introduces key idea EFF strategy wlfich comes observations method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Section 3 4 introduce LING method SING method, respectively.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Complex FSs complex FSs feature values share certain values among features.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	properties enable flexible descriptions.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example type symbol lattice shown Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	1.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	extended complex FS represented type symbol set feature-value pairs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Extended complex FSs called typed feature structures (TFSs).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	2.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unification example shown Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	3.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	TFSs convenient describing linguistic information unlfication-based formalisms.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	4.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	process finishes, COPY slot values ignored thus original structures destroyed.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unification procedure based method takes input two nodes roots DGs unified.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Next, procedure calculates meet type symbol.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	output node created neither input node current; otherwise output node existing current node.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Next, procedure treats arcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	arguments gives one list arcs whose labels unique one input list.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unification procedure first treats arc pairs obtained SharedArcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Next, procedure treats arcs obtained ComplementArcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	arc value copied arc label copied value added output node.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example, consider case feature first treated root nodes G1 G2 Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	5.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unification procedure applied recursively feature values input nodes.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	whole subgraph rooted 6 l/<a c> copied.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	subgraphs modified later.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	node2 = Dereferencelnode2).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Eq?(nodel, node2) Return(node1).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE outnode = GetOutNode(nodel, node2, meet).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE AddArc(outnode, sharedl.label, arcnode).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	AddArc(outnode, complement.label, newnode).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Return(outnode).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	order related unification failure tendency.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Unification fails treating arcs common labels often treating arcs unique labels.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	order strategy generalized EFF applied ordering arcs common labels.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Section 5, method uses generalized strategy proposed.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	5 due change node G3/<a c g>).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	achieve this, I, LING unification method, uses copy dependency information, developed.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	slot pairs consisting nodes arcs value.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	6).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	substitutes arcs newly copied nodes existing arcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	efficiency LING unification method depends proportion newly created structures unification result structures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Current?(node) Return(node).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	node.copy = newnode.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE AddArc(newnode, arc.label, arc.value).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDIF Returo(newnode).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Return(Nil_).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	newarcs = {newarc} U newarcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDIF Return(newarcs).	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	However, two cases rare.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Usually, number features two input structures relatively small sizes two input structures often different.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	SING unification method uses failure tendency infornmtion.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	unification failure tendencies depend systems analysis systems generation systems.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Unlike analysis case, unification features semantic representations tends fail.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	method, theretbre, failure tendency information acquired learning process.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	type symbol 'rFS represents salient information whole TFS.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	achieved sorting procedure common label arc pairs attached meet type symbol.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	However, cases occur practice.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	cases, SING unification method obtains efl]ciency gains.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Structure sharing avoids memory wastage'.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	reduces repeated calculation substructures.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	SING unification method introduces concept feature unification strategy.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	'the method treats features tending fail unification first.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
versions based efficient graph unification methods Wroblewski&apos;s Kogure&apos;s method [23, 16] also developed.	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Strategic Lazy Incremental Copy Graph Unification	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example, spoken Present.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	methods uses rooted directed graphs (DGs) represent FSs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	methods take two DGs inputs give unification result DG.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Previous research identified DG copying significant overhead.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Ile proposed incremental copy graph unification method avoid copying early copying.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	itowever, problem method unitication result graph consists newly created structures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Copying sharable parts called redundant copying.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	better method would nfinimize copying sharable varts.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	redundantly copied parts relatively large input graphs common feature paths.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	natural language processing, cases ubiquitous.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	I)eveloping method avoids memory wastage important.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Pereira's structure sharing FS unification method avoid problem.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	3'he skeleton part shared one input FSs result FS.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	However, advantages describing rules disadvantages applying tt~e lack control information.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	impossible straightforward unification-based formalisms.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	system advantage processing efficiency disadvantage lacking multidirectionality.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	paper, efficiency procedure- based system introduced FS unification-based system.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Section 2 explains typed feature structures (TFSs) unification them.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	section also introduces key idea EFF strategy wlfich comes observations method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Section 3 4 introduce LING method SING method, respectively.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Complex FSs complex FSs feature values share certain values among features.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	properties enable flexible descriptions.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example type symbol lattice shown Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	1.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	extended complex FS represented type symbol set feature-value pairs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Extended complex FSs called typed feature structures (TFSs).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	2.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unification example shown Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	3.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	TFSs convenient describing linguistic information unlfication-based formalisms.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	4.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	process finishes, COPY slot values ignored thus original structures destroyed.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unification procedure based method takes input two nodes roots DGs unified.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Next, procedure calculates meet type symbol.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	output node created neither input node current; otherwise output node existing current node.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Next, procedure treats arcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	arguments gives one list arcs whose labels unique one input list.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unification procedure first treats arc pairs obtained SharedArcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Next, procedure treats arcs obtained ComplementArcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	arc value copied arc label copied value added output node.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example, consider case feature first treated root nodes G1 G2 Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	5.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unification procedure applied recursively feature values input nodes.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	whole subgraph rooted 6 l/<a c> copied.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	subgraphs modified later.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	node2 = Dereferencelnode2).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Eq?(nodel, node2) Return(node1).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE outnode = GetOutNode(nodel, node2, meet).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE AddArc(outnode, sharedl.label, arcnode).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	AddArc(outnode, complement.label, newnode).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Return(outnode).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	order related unification failure tendency.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Unification fails treating arcs common labels often treating arcs unique labels.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	order strategy generalized EFF applied ordering arcs common labels.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Section 5, method uses generalized strategy proposed.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	5 due change node G3/<a c g>).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	achieve this, I, LING unification method, uses copy dependency information, developed.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	slot pairs consisting nodes arcs value.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	6).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	substitutes arcs newly copied nodes existing arcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	efficiency LING unification method depends proportion newly created structures unification result structures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Current?(node) Return(node).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	node.copy = newnode.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE AddArc(newnode, arc.label, arc.value).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDIF Returo(newnode).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Return(Nil_).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	newarcs = {newarc} U newarcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDIF Return(newarcs).	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	However, two cases rare.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Usually, number features two input structures relatively small sizes two input structures often different.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	SING unification method uses failure tendency infornmtion.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	unification failure tendencies depend systems analysis systems generation systems.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Unlike analysis case, unification features semantic representations tends fail.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	method, theretbre, failure tendency information acquired learning process.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	type symbol 'rFS represents salient information whole TFS.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	achieved sorting procedure common label arc pairs attached meet type symbol.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	However, cases occur practice.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	cases, SING unification method obtains efl]ciency gains.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Structure sharing avoids memory wastage'.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	reduces repeated calculation substructures.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	SING unification method introduces concept feature unification strategy.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	'the method treats features tending fail unification first.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
"inefficient many copy operations due unfications unnecessary features contribute successful unification [6].</S><S sid =""103"" ssid = ""68"">Thus treatments strategic unification [6] developed."	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
observation basis reordering method proposed Kogure [1990].	Strategic Lazy Incremental Copy Graph Unification	0
observation basis reordering method proposed Kogure [1990].	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
observation basis reordering method proposed Kogure [1990].	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
observation basis reordering method proposed Kogure [1990].	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
observation basis reordering method proposed Kogure [1990].	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
observation basis reordering method proposed Kogure [1990].	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
observation basis reordering method proposed Kogure [1990].	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
observation basis reordering method proposed Kogure [1990].	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
observation basis reordering method proposed Kogure [1990].	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
observation basis reordering method proposed Kogure [1990].	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
observation basis reordering method proposed Kogure [1990].	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
observation basis reordering method proposed Kogure [1990].	example, spoken Present.	0
observation basis reordering method proposed Kogure [1990].	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
observation basis reordering method proposed Kogure [1990].	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
observation basis reordering method proposed Kogure [1990].	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
observation basis reordering method proposed Kogure [1990].	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
observation basis reordering method proposed Kogure [1990].	methods uses rooted directed graphs (DGs) represent FSs.	0
observation basis reordering method proposed Kogure [1990].	methods take two DGs inputs give unification result DG.	0
observation basis reordering method proposed Kogure [1990].	Previous research identified DG copying significant overhead.	0
observation basis reordering method proposed Kogure [1990].	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
observation basis reordering method proposed Kogure [1990].	Ile proposed incremental copy graph unification method avoid copying early copying.	0
observation basis reordering method proposed Kogure [1990].	itowever, problem method unitication result graph consists newly created structures.	0
observation basis reordering method proposed Kogure [1990].	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
observation basis reordering method proposed Kogure [1990].	Copying sharable parts called redundant copying.	0
observation basis reordering method proposed Kogure [1990].	better method would nfinimize copying sharable varts.	0
observation basis reordering method proposed Kogure [1990].	redundantly copied parts relatively large input graphs common feature paths.	0
observation basis reordering method proposed Kogure [1990].	natural language processing, cases ubiquitous.	0
observation basis reordering method proposed Kogure [1990].	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
observation basis reordering method proposed Kogure [1990].	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
observation basis reordering method proposed Kogure [1990].	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
observation basis reordering method proposed Kogure [1990].	I)eveloping method avoids memory wastage important.	0
observation basis reordering method proposed Kogure [1990].	Pereira's structure sharing FS unification method avoid problem.	0
observation basis reordering method proposed Kogure [1990].	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
observation basis reordering method proposed Kogure [1990].	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
observation basis reordering method proposed Kogure [1990].	3'he skeleton part shared one input FSs result FS.	0
observation basis reordering method proposed Kogure [1990].	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
observation basis reordering method proposed Kogure [1990].	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
observation basis reordering method proposed Kogure [1990].	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
observation basis reordering method proposed Kogure [1990].	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
observation basis reordering method proposed Kogure [1990].	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
observation basis reordering method proposed Kogure [1990].	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
observation basis reordering method proposed Kogure [1990].	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
observation basis reordering method proposed Kogure [1990].	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
observation basis reordering method proposed Kogure [1990].	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
observation basis reordering method proposed Kogure [1990].	However, advantages describing rules disadvantages applying tt~e lack control information.	0
observation basis reordering method proposed Kogure [1990].	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
observation basis reordering method proposed Kogure [1990].	impossible straightforward unification-based formalisms.	0
observation basis reordering method proposed Kogure [1990].	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
observation basis reordering method proposed Kogure [1990].	system advantage processing efficiency disadvantage lacking multidirectionality.	0
observation basis reordering method proposed Kogure [1990].	paper, efficiency procedure- based system introduced FS unification-based system.	0
observation basis reordering method proposed Kogure [1990].	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
observation basis reordering method proposed Kogure [1990].	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
observation basis reordering method proposed Kogure [1990].	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
observation basis reordering method proposed Kogure [1990].	Section 2 explains typed feature structures (TFSs) unification them.	0
observation basis reordering method proposed Kogure [1990].	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
observation basis reordering method proposed Kogure [1990].	section also introduces key idea EFF strategy wlfich comes observations method.	0
observation basis reordering method proposed Kogure [1990].	Section 3 4 introduce LING method SING method, respectively.	0
observation basis reordering method proposed Kogure [1990].	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
observation basis reordering method proposed Kogure [1990].	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
observation basis reordering method proposed Kogure [1990].	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
observation basis reordering method proposed Kogure [1990].	Complex FSs complex FSs feature values share certain values among features.	0
observation basis reordering method proposed Kogure [1990].	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
observation basis reordering method proposed Kogure [1990].	properties enable flexible descriptions.	0
observation basis reordering method proposed Kogure [1990].	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
observation basis reordering method proposed Kogure [1990].	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
observation basis reordering method proposed Kogure [1990].	example type symbol lattice shown Fig.	0
observation basis reordering method proposed Kogure [1990].	1.	0
observation basis reordering method proposed Kogure [1990].	extended complex FS represented type symbol set feature-value pairs.	0
observation basis reordering method proposed Kogure [1990].	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
observation basis reordering method proposed Kogure [1990].	Extended complex FSs called typed feature structures (TFSs).	0
observation basis reordering method proposed Kogure [1990].	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
observation basis reordering method proposed Kogure [1990].	2.	0
observation basis reordering method proposed Kogure [1990].	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
observation basis reordering method proposed Kogure [1990].	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
observation basis reordering method proposed Kogure [1990].	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
observation basis reordering method proposed Kogure [1990].	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
observation basis reordering method proposed Kogure [1990].	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
observation basis reordering method proposed Kogure [1990].	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
observation basis reordering method proposed Kogure [1990].	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
observation basis reordering method proposed Kogure [1990].	unification example shown Fig.	0
observation basis reordering method proposed Kogure [1990].	3.	0
observation basis reordering method proposed Kogure [1990].	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
observation basis reordering method proposed Kogure [1990].	TFSs convenient describing linguistic information unlfication-based formalisms.	0
observation basis reordering method proposed Kogure [1990].	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
observation basis reordering method proposed Kogure [1990].	4.	0
observation basis reordering method proposed Kogure [1990].	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
observation basis reordering method proposed Kogure [1990].	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
observation basis reordering method proposed Kogure [1990].	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
observation basis reordering method proposed Kogure [1990].	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
observation basis reordering method proposed Kogure [1990].	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
observation basis reordering method proposed Kogure [1990].	process finishes, COPY slot values ignored thus original structures destroyed.	0
observation basis reordering method proposed Kogure [1990].	unification procedure based method takes input two nodes roots DGs unified.	0
observation basis reordering method proposed Kogure [1990].	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
observation basis reordering method proposed Kogure [1990].	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
observation basis reordering method proposed Kogure [1990].	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
observation basis reordering method proposed Kogure [1990].	Next, procedure calculates meet type symbol.	0
observation basis reordering method proposed Kogure [1990].	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
observation basis reordering method proposed Kogure [1990].	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
observation basis reordering method proposed Kogure [1990].	output node created neither input node current; otherwise output node existing current node.	0
observation basis reordering method proposed Kogure [1990].	Next, procedure treats arcs.	0
observation basis reordering method proposed Kogure [1990].	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
observation basis reordering method proposed Kogure [1990].	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
observation basis reordering method proposed Kogure [1990].	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
observation basis reordering method proposed Kogure [1990].	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
observation basis reordering method proposed Kogure [1990].	arguments gives one list arcs whose labels unique one input list.	0
observation basis reordering method proposed Kogure [1990].	unification procedure first treats arc pairs obtained SharedArcs.	0
observation basis reordering method proposed Kogure [1990].	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
observation basis reordering method proposed Kogure [1990].	Next, procedure treats arcs obtained ComplementArcs.	0
observation basis reordering method proposed Kogure [1990].	arc value copied arc label copied value added output node.	0
observation basis reordering method proposed Kogure [1990].	example, consider case feature first treated root nodes G1 G2 Fig.	0
observation basis reordering method proposed Kogure [1990].	5.	0
observation basis reordering method proposed Kogure [1990].	unification procedure applied recursively feature values input nodes.	0
observation basis reordering method proposed Kogure [1990].	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
observation basis reordering method proposed Kogure [1990].	whole subgraph rooted 6 l/<a c> copied.	0
observation basis reordering method proposed Kogure [1990].	subgraphs modified later.	0
observation basis reordering method proposed Kogure [1990].	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
observation basis reordering method proposed Kogure [1990].	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
observation basis reordering method proposed Kogure [1990].	node2 = Dereferencelnode2).	0
observation basis reordering method proposed Kogure [1990].	Eq?(nodel, node2) Return(node1).	0
observation basis reordering method proposed Kogure [1990].	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
observation basis reordering method proposed Kogure [1990].	ELSE outnode = GetOutNode(nodel, node2, meet).	0
observation basis reordering method proposed Kogure [1990].	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
observation basis reordering method proposed Kogure [1990].	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
observation basis reordering method proposed Kogure [1990].	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
observation basis reordering method proposed Kogure [1990].	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
observation basis reordering method proposed Kogure [1990].	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
observation basis reordering method proposed Kogure [1990].	ELSE AddArc(outnode, sharedl.label, arcnode).	0
observation basis reordering method proposed Kogure [1990].	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
observation basis reordering method proposed Kogure [1990].	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
observation basis reordering method proposed Kogure [1990].	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
observation basis reordering method proposed Kogure [1990].	AddArc(outnode, complement.label, newnode).	0
observation basis reordering method proposed Kogure [1990].	Return(outnode).	0
observation basis reordering method proposed Kogure [1990].	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
observation basis reordering method proposed Kogure [1990].	example Fig.	0
observation basis reordering method proposed Kogure [1990].	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
observation basis reordering method proposed Kogure [1990].	order related unification failure tendency.	0
observation basis reordering method proposed Kogure [1990].	Unification fails treating arcs common labels often treating arcs unique labels.	0
observation basis reordering method proposed Kogure [1990].	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
observation basis reordering method proposed Kogure [1990].	order strategy generalized EFF applied ordering arcs common labels.	0
observation basis reordering method proposed Kogure [1990].	Section 5, method uses generalized strategy proposed.	0
observation basis reordering method proposed Kogure [1990].	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
observation basis reordering method proposed Kogure [1990].	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
observation basis reordering method proposed Kogure [1990].	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
observation basis reordering method proposed Kogure [1990].	5 due change node G3/<a c g>).	0
observation basis reordering method proposed Kogure [1990].	achieve this, I, LING unification method, uses copy dependency information, developed.	0
observation basis reordering method proposed Kogure [1990].	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
observation basis reordering method proposed Kogure [1990].	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
observation basis reordering method proposed Kogure [1990].	slot pairs consisting nodes arcs value.	0
observation basis reordering method proposed Kogure [1990].	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
observation basis reordering method proposed Kogure [1990].	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
observation basis reordering method proposed Kogure [1990].	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
observation basis reordering method proposed Kogure [1990].	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
observation basis reordering method proposed Kogure [1990].	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
observation basis reordering method proposed Kogure [1990].	6).	0
observation basis reordering method proposed Kogure [1990].	substitutes arcs newly copied nodes existing arcs.	0
observation basis reordering method proposed Kogure [1990].	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
observation basis reordering method proposed Kogure [1990].	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
observation basis reordering method proposed Kogure [1990].	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
observation basis reordering method proposed Kogure [1990].	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
observation basis reordering method proposed Kogure [1990].	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
observation basis reordering method proposed Kogure [1990].	efficiency LING unification method depends proportion newly created structures unification result structures.	0
observation basis reordering method proposed Kogure [1990].	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
observation basis reordering method proposed Kogure [1990].	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
observation basis reordering method proposed Kogure [1990].	Current?(node) Return(node).	0
observation basis reordering method proposed Kogure [1990].	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
observation basis reordering method proposed Kogure [1990].	node.copy = newnode.	0
observation basis reordering method proposed Kogure [1990].	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
observation basis reordering method proposed Kogure [1990].	ELSE AddArc(newnode, arc.label, arc.value).	0
observation basis reordering method proposed Kogure [1990].	ENDIF Returo(newnode).	0
observation basis reordering method proposed Kogure [1990].	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
observation basis reordering method proposed Kogure [1990].	Return(Nil_).	0
observation basis reordering method proposed Kogure [1990].	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
observation basis reordering method proposed Kogure [1990].	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
observation basis reordering method proposed Kogure [1990].	newarcs = {newarc} U newarcs.	0
observation basis reordering method proposed Kogure [1990].	ENDIF Return(newarcs).	0
observation basis reordering method proposed Kogure [1990].	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
observation basis reordering method proposed Kogure [1990].	However, two cases rare.	0
observation basis reordering method proposed Kogure [1990].	Usually, number features two input structures relatively small sizes two input structures often different.	0
observation basis reordering method proposed Kogure [1990].	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
observation basis reordering method proposed Kogure [1990].	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
observation basis reordering method proposed Kogure [1990].	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
observation basis reordering method proposed Kogure [1990].	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
observation basis reordering method proposed Kogure [1990].	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
observation basis reordering method proposed Kogure [1990].	SING unification method uses failure tendency infornmtion.	0
observation basis reordering method proposed Kogure [1990].	unification failure tendencies depend systems analysis systems generation systems.	0
observation basis reordering method proposed Kogure [1990].	Unlike analysis case, unification features semantic representations tends fail.	0
observation basis reordering method proposed Kogure [1990].	method, theretbre, failure tendency information acquired learning process.	0
observation basis reordering method proposed Kogure [1990].	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
observation basis reordering method proposed Kogure [1990].	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
observation basis reordering method proposed Kogure [1990].	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
observation basis reordering method proposed Kogure [1990].	type symbol 'rFS represents salient information whole TFS.	0
observation basis reordering method proposed Kogure [1990].	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
observation basis reordering method proposed Kogure [1990].	achieved sorting procedure common label arc pairs attached meet type symbol.	0
observation basis reordering method proposed Kogure [1990].	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
observation basis reordering method proposed Kogure [1990].	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
observation basis reordering method proposed Kogure [1990].	However, cases occur practice.	0
observation basis reordering method proposed Kogure [1990].	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
observation basis reordering method proposed Kogure [1990].	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
observation basis reordering method proposed Kogure [1990].	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
observation basis reordering method proposed Kogure [1990].	cases, SING unification method obtains efl]ciency gains.	0
observation basis reordering method proposed Kogure [1990].	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
observation basis reordering method proposed Kogure [1990].	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
observation basis reordering method proposed Kogure [1990].	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
observation basis reordering method proposed Kogure [1990].	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
observation basis reordering method proposed Kogure [1990].	Structure sharing avoids memory wastage'.	0
observation basis reordering method proposed Kogure [1990].	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
observation basis reordering method proposed Kogure [1990].	reduces repeated calculation substructures.	0
observation basis reordering method proposed Kogure [1990].	SING unification method introduces concept feature unification strategy.	0
observation basis reordering method proposed Kogure [1990].	'the method treats features tending fail unification first.	0
observation basis reordering method proposed Kogure [1990].	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
observation basis reordering method proposed Kogure [1990].	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Strategic Lazy Incremental Copy Graph Unification	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example, spoken Present.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	methods uses rooted directed graphs (DGs) represent FSs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	methods take two DGs inputs give unification result DG.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Previous research identified DG copying significant overhead.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Ile proposed incremental copy graph unification method avoid copying early copying.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	itowever, problem method unitication result graph consists newly created structures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Copying sharable parts called redundant copying.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	better method would nfinimize copying sharable varts.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	redundantly copied parts relatively large input graphs common feature paths.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	natural language processing, cases ubiquitous.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	I)eveloping method avoids memory wastage important.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Pereira's structure sharing FS unification method avoid problem.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	3'he skeleton part shared one input FSs result FS.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	However, advantages describing rules disadvantages applying tt~e lack control information.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	impossible straightforward unification-based formalisms.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	system advantage processing efficiency disadvantage lacking multidirectionality.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	paper, efficiency procedure- based system introduced FS unification-based system.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Section 2 explains typed feature structures (TFSs) unification them.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	section also introduces key idea EFF strategy wlfich comes observations method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Section 3 4 introduce LING method SING method, respectively.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Complex FSs complex FSs feature values share certain values among features.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	properties enable flexible descriptions.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example type symbol lattice shown Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	1.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	extended complex FS represented type symbol set feature-value pairs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Extended complex FSs called typed feature structures (TFSs).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	2.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unification example shown Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	3.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	TFSs convenient describing linguistic information unlfication-based formalisms.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	4.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	process finishes, COPY slot values ignored thus original structures destroyed.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unification procedure based method takes input two nodes roots DGs unified.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Next, procedure calculates meet type symbol.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	output node created neither input node current; otherwise output node existing current node.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Next, procedure treats arcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	arguments gives one list arcs whose labels unique one input list.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unification procedure first treats arc pairs obtained SharedArcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Next, procedure treats arcs obtained ComplementArcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	arc value copied arc label copied value added output node.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example, consider case feature first treated root nodes G1 G2 Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	5.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unification procedure applied recursively feature values input nodes.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	whole subgraph rooted 6 l/<a c> copied.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	subgraphs modified later.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	node2 = Dereferencelnode2).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Eq?(nodel, node2) Return(node1).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE outnode = GetOutNode(nodel, node2, meet).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE AddArc(outnode, sharedl.label, arcnode).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	AddArc(outnode, complement.label, newnode).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Return(outnode).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	order related unification failure tendency.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Unification fails treating arcs common labels often treating arcs unique labels.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	order strategy generalized EFF applied ordering arcs common labels.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Section 5, method uses generalized strategy proposed.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	5 due change node G3/<a c g>).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	achieve this, I, LING unification method, uses copy dependency information, developed.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	slot pairs consisting nodes arcs value.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	6).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	substitutes arcs newly copied nodes existing arcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	efficiency LING unification method depends proportion newly created structures unification result structures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Current?(node) Return(node).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	node.copy = newnode.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE AddArc(newnode, arc.label, arc.value).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDIF Returo(newnode).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Return(Nil_).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	newarcs = {newarc} U newarcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDIF Return(newarcs).	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	However, two cases rare.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Usually, number features two input structures relatively small sizes two input structures often different.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	SING unification method uses failure tendency infornmtion.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	unification failure tendencies depend systems analysis systems generation systems.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Unlike analysis case, unification features semantic representations tends fail.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	method, theretbre, failure tendency information acquired learning process.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	type symbol 'rFS represents salient information whole TFS.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	achieved sorting procedure common label arc pairs attached meet type symbol.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	However, cases occur practice.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	cases, SING unification method obtains efl]ciency gains.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Structure sharing avoids memory wastage'.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	reduces repeated calculation substructures.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	SING unification method introduces concept feature unification strategy.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	'the method treats features tending fail unification first.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
Thus automatic counting scheme constant shuffling reshuffling conjunct order needs applied order stabilizes (see also [Kogure 1990]).	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Strategic Lazy Incremental Copy Graph Unification	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example, spoken Present.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	methods uses rooted directed graphs (DGs) represent FSs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	methods take two DGs inputs give unification result DG.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Previous research identified DG copying significant overhead.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Ile proposed incremental copy graph unification method avoid copying early copying.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	itowever, problem method unitication result graph consists newly created structures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Copying sharable parts called redundant copying.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	better method would nfinimize copying sharable varts.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	redundantly copied parts relatively large input graphs common feature paths.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	natural language processing, cases ubiquitous.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	I)eveloping method avoids memory wastage important.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Pereira's structure sharing FS unification method avoid problem.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	3'he skeleton part shared one input FSs result FS.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	However, advantages describing rules disadvantages applying tt~e lack control information.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	impossible straightforward unification-based formalisms.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	system advantage processing efficiency disadvantage lacking multidirectionality.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	paper, efficiency procedure- based system introduced FS unification-based system.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Section 2 explains typed feature structures (TFSs) unification them.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	section also introduces key idea EFF strategy wlfich comes observations method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Section 3 4 introduce LING method SING method, respectively.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Complex FSs complex FSs feature values share certain values among features.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	properties enable flexible descriptions.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example type symbol lattice shown Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	1.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	extended complex FS represented type symbol set feature-value pairs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Extended complex FSs called typed feature structures (TFSs).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	2.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unification example shown Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	3.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	TFSs convenient describing linguistic information unlfication-based formalisms.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	4.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	process finishes, COPY slot values ignored thus original structures destroyed.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unification procedure based method takes input two nodes roots DGs unified.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Next, procedure calculates meet type symbol.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	output node created neither input node current; otherwise output node existing current node.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Next, procedure treats arcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	arguments gives one list arcs whose labels unique one input list.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unification procedure first treats arc pairs obtained SharedArcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Next, procedure treats arcs obtained ComplementArcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	arc value copied arc label copied value added output node.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example, consider case feature first treated root nodes G1 G2 Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	5.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unification procedure applied recursively feature values input nodes.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	whole subgraph rooted 6 l/<a c> copied.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	subgraphs modified later.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	node2 = Dereferencelnode2).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Eq?(nodel, node2) Return(node1).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE outnode = GetOutNode(nodel, node2, meet).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE AddArc(outnode, sharedl.label, arcnode).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	AddArc(outnode, complement.label, newnode).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Return(outnode).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	order related unification failure tendency.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Unification fails treating arcs common labels often treating arcs unique labels.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	order strategy generalized EFF applied ordering arcs common labels.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Section 5, method uses generalized strategy proposed.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	5 due change node G3/<a c g>).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	achieve this, I, LING unification method, uses copy dependency information, developed.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	slot pairs consisting nodes arcs value.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	6).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	substitutes arcs newly copied nodes existing arcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	efficiency LING unification method depends proportion newly created structures unification result structures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Current?(node) Return(node).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	node.copy = newnode.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE AddArc(newnode, arc.label, arc.value).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDIF Returo(newnode).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Return(Nil_).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	newarcs = {newarc} U newarcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDIF Return(newarcs).	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	However, two cases rare.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Usually, number features two input structures relatively small sizes two input structures often different.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	SING unification method uses failure tendency infornmtion.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	unification failure tendencies depend systems analysis systems generation systems.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Unlike analysis case, unification features semantic representations tends fail.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	method, theretbre, failure tendency information acquired learning process.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	type symbol 'rFS represents salient information whole TFS.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	achieved sorting procedure common label arc pairs attached meet type symbol.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	However, cases occur practice.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	cases, SING unification method obtains efl]ciency gains.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Structure sharing avoids memory wastage'.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	reduces repeated calculation substructures.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	SING unification method introduces concept feature unification strategy.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	'the method treats features tending fail unification first.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
lazy copying approach ([Kogure, 1990], [Emele, 1991] lazy copying TFS historical backtracking) copies overlapping parts structure.	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Strategic Lazy Incremental Copy Graph Unification	1
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example, spoken Present.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	methods uses rooted directed graphs (DGs) represent FSs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	methods take two DGs inputs give unification result DG.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Previous research identified DG copying significant overhead.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Ile proposed incremental copy graph unification method avoid copying early copying.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	itowever, problem method unitication result graph consists newly created structures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Copying sharable parts called redundant copying.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	better method would nfinimize copying sharable varts.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	redundantly copied parts relatively large input graphs common feature paths.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	natural language processing, cases ubiquitous.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	I)eveloping method avoids memory wastage important.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Pereira's structure sharing FS unification method avoid problem.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	3'he skeleton part shared one input FSs result FS.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	However, advantages describing rules disadvantages applying tt~e lack control information.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	impossible straightforward unification-based formalisms.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	system advantage processing efficiency disadvantage lacking multidirectionality.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	paper, efficiency procedure- based system introduced FS unification-based system.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Section 2 explains typed feature structures (TFSs) unification them.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	section also introduces key idea EFF strategy wlfich comes observations method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Section 3 4 introduce LING method SING method, respectively.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Complex FSs complex FSs feature values share certain values among features.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	properties enable flexible descriptions.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example type symbol lattice shown Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	1.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	extended complex FS represented type symbol set feature-value pairs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Extended complex FSs called typed feature structures (TFSs).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	2.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unification example shown Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	3.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	TFSs convenient describing linguistic information unlfication-based formalisms.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	4.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	process finishes, COPY slot values ignored thus original structures destroyed.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unification procedure based method takes input two nodes roots DGs unified.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Next, procedure calculates meet type symbol.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	output node created neither input node current; otherwise output node existing current node.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Next, procedure treats arcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	arguments gives one list arcs whose labels unique one input list.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unification procedure first treats arc pairs obtained SharedArcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Next, procedure treats arcs obtained ComplementArcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	arc value copied arc label copied value added output node.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example, consider case feature first treated root nodes G1 G2 Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	5.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unification procedure applied recursively feature values input nodes.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	whole subgraph rooted 6 l/<a c> copied.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	subgraphs modified later.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	node2 = Dereferencelnode2).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Eq?(nodel, node2) Return(node1).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE outnode = GetOutNode(nodel, node2, meet).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE AddArc(outnode, sharedl.label, arcnode).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	AddArc(outnode, complement.label, newnode).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Return(outnode).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	order related unification failure tendency.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Unification fails treating arcs common labels often treating arcs unique labels.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	order strategy generalized EFF applied ordering arcs common labels.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Section 5, method uses generalized strategy proposed.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	5 due change node G3/<a c g>).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	achieve this, I, LING unification method, uses copy dependency information, developed.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	slot pairs consisting nodes arcs value.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	6).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	substitutes arcs newly copied nodes existing arcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	efficiency LING unification method depends proportion newly created structures unification result structures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Current?(node) Return(node).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	node.copy = newnode.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE AddArc(newnode, arc.label, arc.value).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDIF Returo(newnode).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Return(Nil_).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	newarcs = {newarc} U newarcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDIF Return(newarcs).	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	However, two cases rare.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Usually, number features two input structures relatively small sizes two input structures often different.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	SING unification method uses failure tendency infornmtion.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	unification failure tendencies depend systems analysis systems generation systems.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Unlike analysis case, unification features semantic representations tends fail.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	method, theretbre, failure tendency information acquired learning process.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	type symbol 'rFS represents salient information whole TFS.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	achieved sorting procedure common label arc pairs attached meet type symbol.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	However, cases occur practice.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	cases, SING unification method obtains efl]ciency gains.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Structure sharing avoids memory wastage'.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	reduces repeated calculation substructures.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	SING unification method introduces concept feature unification strategy.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	'the method treats features tending fail unification first.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
"least two schemes proposed recently ])a.~ed Ul)OU observation (namely [Kogure.</S> <S sid =""18"" ssid = ""18"">1990] [Emele, 1991]); however, schemes I)ased upon increlllent&apos;al Col)yiug sehellle all(l ~-LS ([e- scribed [Tomal)eehi, 1991] incremental copying schemes inherently suffcr fi&apos;om Early Copying defined article."	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Strategic Lazy Incremental Copy Graph Unification	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example, spoken Present.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	methods uses rooted directed graphs (DGs) represent FSs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	methods take two DGs inputs give unification result DG.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Previous research identified DG copying significant overhead.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Ile proposed incremental copy graph unification method avoid copying early copying.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	itowever, problem method unitication result graph consists newly created structures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Copying sharable parts called redundant copying.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	better method would nfinimize copying sharable varts.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	redundantly copied parts relatively large input graphs common feature paths.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	natural language processing, cases ubiquitous.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	I)eveloping method avoids memory wastage important.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Pereira's structure sharing FS unification method avoid problem.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	3'he skeleton part shared one input FSs result FS.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	However, advantages describing rules disadvantages applying tt~e lack control information.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	impossible straightforward unification-based formalisms.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	system advantage processing efficiency disadvantage lacking multidirectionality.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	paper, efficiency procedure- based system introduced FS unification-based system.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Section 2 explains typed feature structures (TFSs) unification them.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	section also introduces key idea EFF strategy wlfich comes observations method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Section 3 4 introduce LING method SING method, respectively.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Complex FSs complex FSs feature values share certain values among features.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	properties enable flexible descriptions.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example type symbol lattice shown Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	1.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	extended complex FS represented type symbol set feature-value pairs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Extended complex FSs called typed feature structures (TFSs).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	2.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unification example shown Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	3.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	TFSs convenient describing linguistic information unlfication-based formalisms.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	4.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	process finishes, COPY slot values ignored thus original structures destroyed.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unification procedure based method takes input two nodes roots DGs unified.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Next, procedure calculates meet type symbol.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	output node created neither input node current; otherwise output node existing current node.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Next, procedure treats arcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	arguments gives one list arcs whose labels unique one input list.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unification procedure first treats arc pairs obtained SharedArcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Next, procedure treats arcs obtained ComplementArcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	arc value copied arc label copied value added output node.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example, consider case feature first treated root nodes G1 G2 Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	5.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unification procedure applied recursively feature values input nodes.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	whole subgraph rooted 6 l/<a c> copied.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	subgraphs modified later.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	node2 = Dereferencelnode2).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Eq?(nodel, node2) Return(node1).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE outnode = GetOutNode(nodel, node2, meet).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE AddArc(outnode, sharedl.label, arcnode).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	AddArc(outnode, complement.label, newnode).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Return(outnode).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	order related unification failure tendency.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Unification fails treating arcs common labels often treating arcs unique labels.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	order strategy generalized EFF applied ordering arcs common labels.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Section 5, method uses generalized strategy proposed.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	5 due change node G3/<a c g>).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	achieve this, I, LING unification method, uses copy dependency information, developed.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	slot pairs consisting nodes arcs value.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	6).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	substitutes arcs newly copied nodes existing arcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	efficiency LING unification method depends proportion newly created structures unification result structures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Current?(node) Return(node).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	node.copy = newnode.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE AddArc(newnode, arc.label, arc.value).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDIF Returo(newnode).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Return(Nil_).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	newarcs = {newarc} U newarcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDIF Return(newarcs).	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	However, two cases rare.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Usually, number features two input structures relatively small sizes two input structures often different.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	SING unification method uses failure tendency infornmtion.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	unification failure tendencies depend systems analysis systems generation systems.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Unlike analysis case, unification features semantic representations tends fail.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	method, theretbre, failure tendency information acquired learning process.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	type symbol 'rFS represents salient information whole TFS.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	achieved sorting procedure common label arc pairs attached meet type symbol.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	However, cases occur practice.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	cases, SING unification method obtains efl]ciency gains.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Structure sharing avoids memory wastage'.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	reduces repeated calculation substructures.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	SING unification method introduces concept feature unification strategy.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	'the method treats features tending fail unification first.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
• Data-Structure Sharing: Two distinct graphs share subgraph converging node notion structure-sharing data structure level. [Kogure, 1990] calls copying structures Redundant Copying.	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Strategic Lazy Incremental Copy Graph Unification	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example, spoken Present.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	methods uses rooted directed graphs (DGs) represent FSs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	methods take two DGs inputs give unification result DG.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Previous research identified DG copying significant overhead.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Ile proposed incremental copy graph unification method avoid copying early copying.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	itowever, problem method unitication result graph consists newly created structures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Copying sharable parts called redundant copying.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	better method would nfinimize copying sharable varts.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	redundantly copied parts relatively large input graphs common feature paths.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	natural language processing, cases ubiquitous.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	I)eveloping method avoids memory wastage important.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Pereira's structure sharing FS unification method avoid problem.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	3'he skeleton part shared one input FSs result FS.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	However, advantages describing rules disadvantages applying tt~e lack control information.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	impossible straightforward unification-based formalisms.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	system advantage processing efficiency disadvantage lacking multidirectionality.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	paper, efficiency procedure- based system introduced FS unification-based system.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Section 2 explains typed feature structures (TFSs) unification them.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	section also introduces key idea EFF strategy wlfich comes observations method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Section 3 4 introduce LING method SING method, respectively.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Complex FSs complex FSs feature values share certain values among features.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	properties enable flexible descriptions.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example type symbol lattice shown Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	1.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	extended complex FS represented type symbol set feature-value pairs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Extended complex FSs called typed feature structures (TFSs).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	2.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unification example shown Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	3.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	TFSs convenient describing linguistic information unlfication-based formalisms.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	4.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	process finishes, COPY slot values ignored thus original structures destroyed.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unification procedure based method takes input two nodes roots DGs unified.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Next, procedure calculates meet type symbol.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	output node created neither input node current; otherwise output node existing current node.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Next, procedure treats arcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	arguments gives one list arcs whose labels unique one input list.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unification procedure first treats arc pairs obtained SharedArcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Next, procedure treats arcs obtained ComplementArcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	arc value copied arc label copied value added output node.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example, consider case feature first treated root nodes G1 G2 Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	5.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unification procedure applied recursively feature values input nodes.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	whole subgraph rooted 6 l/<a c> copied.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	subgraphs modified later.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	node2 = Dereferencelnode2).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Eq?(nodel, node2) Return(node1).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE outnode = GetOutNode(nodel, node2, meet).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE AddArc(outnode, sharedl.label, arcnode).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	AddArc(outnode, complement.label, newnode).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Return(outnode).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	order related unification failure tendency.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Unification fails treating arcs common labels often treating arcs unique labels.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	order strategy generalized EFF applied ordering arcs common labels.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Section 5, method uses generalized strategy proposed.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	5 due change node G3/<a c g>).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	achieve this, I, LING unification method, uses copy dependency information, developed.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	slot pairs consisting nodes arcs value.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	6).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	substitutes arcs newly copied nodes existing arcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	efficiency LING unification method depends proportion newly created structures unification result structures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Current?(node) Return(node).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	node.copy = newnode.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE AddArc(newnode, arc.label, arc.value).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDIF Returo(newnode).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Return(Nil_).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	newarcs = {newarc} U newarcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDIF Return(newarcs).	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	However, two cases rare.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Usually, number features two input structures relatively small sizes two input structures often different.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	SING unification method uses failure tendency infornmtion.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	unification failure tendencies depend systems analysis systems generation systems.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Unlike analysis case, unification features semantic representations tends fail.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	method, theretbre, failure tendency information acquired learning process.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	type symbol 'rFS represents salient information whole TFS.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	achieved sorting procedure common label arc pairs attached meet type symbol.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	However, cases occur practice.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	cases, SING unification method obtains efl]ciency gains.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Structure sharing avoids memory wastage'.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	1
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	reduces repeated calculation substructures.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	SING unification method introduces concept feature unification strategy.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	'the method treats features tending fail unification first.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
2In large-scale HPSG-based spoken Japanese analysis system developed ATR, sometimes 98 percent elapsed time devoted graph unification ([Kogure, 1990]).	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Strategic Lazy Incremental Copy Graph Unification	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example, spoken Present.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	methods uses rooted directed graphs (DGs) represent FSs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	methods take two DGs inputs give unification result DG.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Previous research identified DG copying significant overhead.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Ile proposed incremental copy graph unification method avoid copying early copying.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	itowever, problem method unitication result graph consists newly created structures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Copying sharable parts called redundant copying.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	better method would nfinimize copying sharable varts.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	redundantly copied parts relatively large input graphs common feature paths.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	natural language processing, cases ubiquitous.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	I)eveloping method avoids memory wastage important.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Pereira's structure sharing FS unification method avoid problem.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	3'he skeleton part shared one input FSs result FS.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	However, advantages describing rules disadvantages applying tt~e lack control information.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	impossible straightforward unification-based formalisms.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	system advantage processing efficiency disadvantage lacking multidirectionality.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	paper, efficiency procedure- based system introduced FS unification-based system.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Section 2 explains typed feature structures (TFSs) unification them.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	section also introduces key idea EFF strategy wlfich comes observations method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Section 3 4 introduce LING method SING method, respectively.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Complex FSs complex FSs feature values share certain values among features.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	properties enable flexible descriptions.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example type symbol lattice shown Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	1.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	extended complex FS represented type symbol set feature-value pairs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Extended complex FSs called typed feature structures (TFSs).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	2.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unification example shown Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	3.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	TFSs convenient describing linguistic information unlfication-based formalisms.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	4.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	process finishes, COPY slot values ignored thus original structures destroyed.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unification procedure based method takes input two nodes roots DGs unified.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Next, procedure calculates meet type symbol.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	output node created neither input node current; otherwise output node existing current node.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Next, procedure treats arcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	arguments gives one list arcs whose labels unique one input list.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unification procedure first treats arc pairs obtained SharedArcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Next, procedure treats arcs obtained ComplementArcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	arc value copied arc label copied value added output node.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example, consider case feature first treated root nodes G1 G2 Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	5.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unification procedure applied recursively feature values input nodes.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	whole subgraph rooted 6 l/<a c> copied.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	subgraphs modified later.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	node2 = Dereferencelnode2).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Eq?(nodel, node2) Return(node1).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE outnode = GetOutNode(nodel, node2, meet).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE AddArc(outnode, sharedl.label, arcnode).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	AddArc(outnode, complement.label, newnode).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Return(outnode).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	order related unification failure tendency.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Unification fails treating arcs common labels often treating arcs unique labels.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	order strategy generalized EFF applied ordering arcs common labels.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Section 5, method uses generalized strategy proposed.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	5 due change node G3/<a c g>).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	achieve this, I, LING unification method, uses copy dependency information, developed.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	slot pairs consisting nodes arcs value.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	6).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	substitutes arcs newly copied nodes existing arcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	efficiency LING unification method depends proportion newly created structures unification result structures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Current?(node) Return(node).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	node.copy = newnode.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE AddArc(newnode, arc.label, arc.value).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDIF Returo(newnode).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Return(Nil_).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	newarcs = {newarc} U newarcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDIF Return(newarcs).	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	However, two cases rare.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Usually, number features two input structures relatively small sizes two input structures often different.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	SING unification method uses failure tendency infornmtion.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	unification failure tendencies depend systems analysis systems generation systems.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Unlike analysis case, unification features semantic representations tends fail.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	method, theretbre, failure tendency information acquired learning process.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	type symbol 'rFS represents salient information whole TFS.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	achieved sorting procedure common label arc pairs attached meet type symbol.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	However, cases occur practice.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	cases, SING unification method obtains efl]ciency gains.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Structure sharing avoids memory wastage'.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	reduces repeated calculation substructures.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	SING unification method introduces concept feature unification strategy.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	'the method treats features tending fail unification first.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
is, unless new scheme reducing excessive copying introduced scucture-sharing unchanged shared-forest ([Kogure, 1990]).	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Strategic Lazy Incremental Copy Graph Unification	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example, spoken Present.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	methods uses rooted directed graphs (DGs) represent FSs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	methods take two DGs inputs give unification result DG.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Previous research identified DG copying significant overhead.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Ile proposed incremental copy graph unification method avoid copying early copying.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	itowever, problem method unitication result graph consists newly created structures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Copying sharable parts called redundant copying.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	better method would nfinimize copying sharable varts.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	redundantly copied parts relatively large input graphs common feature paths.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	natural language processing, cases ubiquitous.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	I)eveloping method avoids memory wastage important.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Pereira's structure sharing FS unification method avoid problem.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	3'he skeleton part shared one input FSs result FS.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	However, advantages describing rules disadvantages applying tt~e lack control information.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	impossible straightforward unification-based formalisms.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	system advantage processing efficiency disadvantage lacking multidirectionality.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	paper, efficiency procedure- based system introduced FS unification-based system.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Section 2 explains typed feature structures (TFSs) unification them.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	section also introduces key idea EFF strategy wlfich comes observations method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Section 3 4 introduce LING method SING method, respectively.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Complex FSs complex FSs feature values share certain values among features.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	properties enable flexible descriptions.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example type symbol lattice shown Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	1.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	extended complex FS represented type symbol set feature-value pairs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Extended complex FSs called typed feature structures (TFSs).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	2.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unification example shown Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	3.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	TFSs convenient describing linguistic information unlfication-based formalisms.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	4.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	process finishes, COPY slot values ignored thus original structures destroyed.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unification procedure based method takes input two nodes roots DGs unified.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Next, procedure calculates meet type symbol.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	output node created neither input node current; otherwise output node existing current node.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Next, procedure treats arcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	arguments gives one list arcs whose labels unique one input list.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unification procedure first treats arc pairs obtained SharedArcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Next, procedure treats arcs obtained ComplementArcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	arc value copied arc label copied value added output node.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example, consider case feature first treated root nodes G1 G2 Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	5.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unification procedure applied recursively feature values input nodes.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	whole subgraph rooted 6 l/<a c> copied.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	subgraphs modified later.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	node2 = Dereferencelnode2).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Eq?(nodel, node2) Return(node1).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE outnode = GetOutNode(nodel, node2, meet).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE AddArc(outnode, sharedl.label, arcnode).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	AddArc(outnode, complement.label, newnode).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Return(outnode).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	order related unification failure tendency.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Unification fails treating arcs common labels often treating arcs unique labels.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	order strategy generalized EFF applied ordering arcs common labels.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Section 5, method uses generalized strategy proposed.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	5 due change node G3/<a c g>).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	achieve this, I, LING unification method, uses copy dependency information, developed.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	slot pairs consisting nodes arcs value.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	6).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	substitutes arcs newly copied nodes existing arcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	efficiency LING unification method depends proportion newly created structures unification result structures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Current?(node) Return(node).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	node.copy = newnode.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE AddArc(newnode, arc.label, arc.value).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDIF Returo(newnode).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Return(Nil_).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	newarcs = {newarc} U newarcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDIF Return(newarcs).	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	However, two cases rare.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Usually, number features two input structures relatively small sizes two input structures often different.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	SING unification method uses failure tendency infornmtion.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	unification failure tendencies depend systems analysis systems generation systems.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Unlike analysis case, unification features semantic representations tends fail.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	method, theretbre, failure tendency information acquired learning process.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	type symbol 'rFS represents salient information whole TFS.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	achieved sorting procedure common label arc pairs attached meet type symbol.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	However, cases occur practice.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	cases, SING unification method obtains efl]ciency gains.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Structure sharing avoids memory wastage'.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	reduces repeated calculation substructures.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	SING unification method introduces concept feature unification strategy.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	'the method treats features tending fail unification first.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
eNcient unification algorithm would avoid redundant copying (copying structures shared input resultant graphs) (Kogure, 1990).	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Strategic Lazy Incremental Copy Graph Unification	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example, spoken Present.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	methods uses rooted directed graphs (DGs) represent FSs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	methods take two DGs inputs give unification result DG.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Previous research identified DG copying significant overhead.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Ile proposed incremental copy graph unification method avoid copying early copying.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	itowever, problem method unitication result graph consists newly created structures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Copying sharable parts called redundant copying.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	better method would nfinimize copying sharable varts.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	redundantly copied parts relatively large input graphs common feature paths.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	natural language processing, cases ubiquitous.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	I)eveloping method avoids memory wastage important.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Pereira's structure sharing FS unification method avoid problem.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	3'he skeleton part shared one input FSs result FS.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	However, advantages describing rules disadvantages applying tt~e lack control information.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	impossible straightforward unification-based formalisms.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	system advantage processing efficiency disadvantage lacking multidirectionality.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	paper, efficiency procedure- based system introduced FS unification-based system.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Section 2 explains typed feature structures (TFSs) unification them.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	section also introduces key idea EFF strategy wlfich comes observations method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Section 3 4 introduce LING method SING method, respectively.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Complex FSs complex FSs feature values share certain values among features.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	properties enable flexible descriptions.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example type symbol lattice shown Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	1.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	extended complex FS represented type symbol set feature-value pairs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Extended complex FSs called typed feature structures (TFSs).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	2.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unification example shown Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	3.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	TFSs convenient describing linguistic information unlfication-based formalisms.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	4.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	process finishes, COPY slot values ignored thus original structures destroyed.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unification procedure based method takes input two nodes roots DGs unified.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Next, procedure calculates meet type symbol.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	output node created neither input node current; otherwise output node existing current node.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Next, procedure treats arcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	arguments gives one list arcs whose labels unique one input list.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unification procedure first treats arc pairs obtained SharedArcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Next, procedure treats arcs obtained ComplementArcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	arc value copied arc label copied value added output node.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example, consider case feature first treated root nodes G1 G2 Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	5.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unification procedure applied recursively feature values input nodes.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	whole subgraph rooted 6 l/<a c> copied.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	subgraphs modified later.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	node2 = Dereferencelnode2).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Eq?(nodel, node2) Return(node1).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE outnode = GetOutNode(nodel, node2, meet).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE AddArc(outnode, sharedl.label, arcnode).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	AddArc(outnode, complement.label, newnode).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Return(outnode).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	order related unification failure tendency.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Unification fails treating arcs common labels often treating arcs unique labels.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	order strategy generalized EFF applied ordering arcs common labels.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Section 5, method uses generalized strategy proposed.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	5 due change node G3/<a c g>).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	achieve this, I, LING unification method, uses copy dependency information, developed.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	slot pairs consisting nodes arcs value.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	6).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	substitutes arcs newly copied nodes existing arcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	efficiency LING unification method depends proportion newly created structures unification result structures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Current?(node) Return(node).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	node.copy = newnode.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE AddArc(newnode, arc.label, arc.value).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDIF Returo(newnode).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Return(Nil_).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	newarcs = {newarc} U newarcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDIF Return(newarcs).	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	However, two cases rare.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Usually, number features two input structures relatively small sizes two input structures often different.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	SING unification method uses failure tendency infornmtion.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	unification failure tendencies depend systems analysis systems generation systems.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Unlike analysis case, unification features semantic representations tends fail.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	method, theretbre, failure tendency information acquired learning process.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	type symbol 'rFS represents salient information whole TFS.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	achieved sorting procedure common label arc pairs attached meet type symbol.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	However, cases occur practice.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	cases, SING unification method obtains efl]ciency gains.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Structure sharing avoids memory wastage'.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	reduces repeated calculation substructures.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	SING unification method introduces concept feature unification strategy.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	'the method treats features tending fail unification first.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
Kogure (1990) proposed lazy incremental copy graph (LING) unification uses dependency-directed eol)yiug	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Strategic Lazy Incremental Copy Graph Unification	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example, spoken Present.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	methods uses rooted directed graphs (DGs) represent FSs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	methods take two DGs inputs give unification result DG.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Previous research identified DG copying significant overhead.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Ile proposed incremental copy graph unification method avoid copying early copying.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	itowever, problem method unitication result graph consists newly created structures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Copying sharable parts called redundant copying.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	better method would nfinimize copying sharable varts.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	redundantly copied parts relatively large input graphs common feature paths.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	natural language processing, cases ubiquitous.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	I)eveloping method avoids memory wastage important.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Pereira's structure sharing FS unification method avoid problem.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	3'he skeleton part shared one input FSs result FS.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	However, advantages describing rules disadvantages applying tt~e lack control information.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	impossible straightforward unification-based formalisms.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	system advantage processing efficiency disadvantage lacking multidirectionality.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	paper, efficiency procedure- based system introduced FS unification-based system.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Section 2 explains typed feature structures (TFSs) unification them.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	section also introduces key idea EFF strategy wlfich comes observations method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Section 3 4 introduce LING method SING method, respectively.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Complex FSs complex FSs feature values share certain values among features.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	properties enable flexible descriptions.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example type symbol lattice shown Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	1.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	extended complex FS represented type symbol set feature-value pairs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Extended complex FSs called typed feature structures (TFSs).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	2.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unification example shown Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	3.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	TFSs convenient describing linguistic information unlfication-based formalisms.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	4.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	process finishes, COPY slot values ignored thus original structures destroyed.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unification procedure based method takes input two nodes roots DGs unified.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Next, procedure calculates meet type symbol.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	output node created neither input node current; otherwise output node existing current node.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Next, procedure treats arcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	arguments gives one list arcs whose labels unique one input list.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unification procedure first treats arc pairs obtained SharedArcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Next, procedure treats arcs obtained ComplementArcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	arc value copied arc label copied value added output node.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example, consider case feature first treated root nodes G1 G2 Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	5.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unification procedure applied recursively feature values input nodes.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	whole subgraph rooted 6 l/<a c> copied.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	subgraphs modified later.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	node2 = Dereferencelnode2).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Eq?(nodel, node2) Return(node1).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE outnode = GetOutNode(nodel, node2, meet).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE AddArc(outnode, sharedl.label, arcnode).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	AddArc(outnode, complement.label, newnode).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Return(outnode).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	order related unification failure tendency.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Unification fails treating arcs common labels often treating arcs unique labels.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	order strategy generalized EFF applied ordering arcs common labels.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Section 5, method uses generalized strategy proposed.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	5 due change node G3/<a c g>).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	achieve this, I, LING unification method, uses copy dependency information, developed.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	slot pairs consisting nodes arcs value.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	6).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	substitutes arcs newly copied nodes existing arcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	efficiency LING unification method depends proportion newly created structures unification result structures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Current?(node) Return(node).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	node.copy = newnode.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE AddArc(newnode, arc.label, arc.value).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDIF Returo(newnode).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Return(Nil_).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	newarcs = {newarc} U newarcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDIF Return(newarcs).	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	However, two cases rare.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Usually, number features two input structures relatively small sizes two input structures often different.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	SING unification method uses failure tendency infornmtion.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	unification failure tendencies depend systems analysis systems generation systems.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Unlike analysis case, unification features semantic representations tends fail.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	method, theretbre, failure tendency information acquired learning process.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	type symbol 'rFS represents salient information whole TFS.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	achieved sorting procedure common label arc pairs attached meet type symbol.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	However, cases occur practice.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	cases, SING unification method obtains efl]ciency gains.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Structure sharing avoids memory wastage'.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	reduces repeated calculation substructures.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	SING unification method introduces concept feature unification strategy.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	'the method treats features tending fail unification first.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
better method would avoid (eliminate) redundant copying called [Kogure 90].	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Strategic Lazy Incremental Copy Graph Unification	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example, spoken Present.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	methods uses rooted directed graphs (DGs) represent FSs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	methods take two DGs inputs give unification result DG.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Previous research identified DG copying significant overhead.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Ile proposed incremental copy graph unification method avoid copying early copying.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	itowever, problem method unitication result graph consists newly created structures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Copying sharable parts called redundant copying.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	better method would nfinimize copying sharable varts.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	redundantly copied parts relatively large input graphs common feature paths.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	natural language processing, cases ubiquitous.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	I)eveloping method avoids memory wastage important.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Pereira's structure sharing FS unification method avoid problem.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	3'he skeleton part shared one input FSs result FS.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	However, advantages describing rules disadvantages applying tt~e lack control information.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	impossible straightforward unification-based formalisms.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	system advantage processing efficiency disadvantage lacking multidirectionality.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	paper, efficiency procedure- based system introduced FS unification-based system.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Section 2 explains typed feature structures (TFSs) unification them.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	section also introduces key idea EFF strategy wlfich comes observations method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Section 3 4 introduce LING method SING method, respectively.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Complex FSs complex FSs feature values share certain values among features.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	properties enable flexible descriptions.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example type symbol lattice shown Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	1.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	extended complex FS represented type symbol set feature-value pairs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Extended complex FSs called typed feature structures (TFSs).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	2.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unification example shown Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	3.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	TFSs convenient describing linguistic information unlfication-based formalisms.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	4.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	process finishes, COPY slot values ignored thus original structures destroyed.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unification procedure based method takes input two nodes roots DGs unified.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Next, procedure calculates meet type symbol.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	output node created neither input node current; otherwise output node existing current node.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Next, procedure treats arcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	arguments gives one list arcs whose labels unique one input list.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unification procedure first treats arc pairs obtained SharedArcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Next, procedure treats arcs obtained ComplementArcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	arc value copied arc label copied value added output node.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example, consider case feature first treated root nodes G1 G2 Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	5.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unification procedure applied recursively feature values input nodes.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	whole subgraph rooted 6 l/<a c> copied.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	subgraphs modified later.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	node2 = Dereferencelnode2).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Eq?(nodel, node2) Return(node1).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE outnode = GetOutNode(nodel, node2, meet).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE AddArc(outnode, sharedl.label, arcnode).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	AddArc(outnode, complement.label, newnode).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Return(outnode).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	order related unification failure tendency.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Unification fails treating arcs common labels often treating arcs unique labels.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	order strategy generalized EFF applied ordering arcs common labels.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Section 5, method uses generalized strategy proposed.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	5 due change node G3/<a c g>).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	achieve this, I, LING unification method, uses copy dependency information, developed.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	slot pairs consisting nodes arcs value.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	6).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	substitutes arcs newly copied nodes existing arcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	efficiency LING unification method depends proportion newly created structures unification result structures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Current?(node) Return(node).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	node.copy = newnode.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE AddArc(newnode, arc.label, arc.value).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDIF Returo(newnode).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Return(Nil_).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	newarcs = {newarc} U newarcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDIF Return(newarcs).	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	However, two cases rare.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Usually, number features two input structures relatively small sizes two input structures often different.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	SING unification method uses failure tendency infornmtion.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	unification failure tendencies depend systems analysis systems generation systems.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Unlike analysis case, unification features semantic representations tends fail.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	method, theretbre, failure tendency information acquired learning process.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	type symbol 'rFS represents salient information whole TFS.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	achieved sorting procedure common label arc pairs attached meet type symbol.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	However, cases occur practice.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	cases, SING unification method obtains efl]ciency gains.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Structure sharing avoids memory wastage'.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	reduces repeated calculation substructures.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	SING unification method introduces concept feature unification strategy.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	'the method treats features tending fail unification first.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
"noticed [Godden 90] [Kogure 90], key idea avoiding &quot;redundant copying&quot; copying lazily.</S><S sid =""117"" ssid = ""117"">Copying nodes delayed destructive change take place.</S><S sid =""118"" ssid = ""118"">Kogure uses revised copynode procedure maintains copy dependency information order avoid immediate copying.</S><S sid =""124"" ssid = ""124"">Similarly, Kogure&apos;s approach, redundant copying avoided cases exists feature path (a sequence nodes connected arcs) node needs copied."	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Strategic Lazy Incremental Copy Graph Unification	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	strategic lazy incremental copy graph unification method combination two methods unifying hmture structures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	One, called lazy incremental copy graph unification method, achieves structure sharing constant order data access time reduces cequired memory.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	other, called ti~e strategic incremental copy graph unification method, uses early failure finding strategy first tries unify :;ubstructures tending fail unification; method is; based stochastic data tim likelihood failure ,'educes unnecessary computation.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	combined method .makes feature structure unification efficient also reduces garbage collection page swapping occurrences, thus increasing total efficiency natural language processing systems mainly based I.yped feature structure unification natural language analysis generation sysl~ems.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Various kinds grammatical formalisms without t,ranstormation proposed late 1970s I;hrough 1980s l(]azder eL al 85, l(aplan Bresnan 82, Kay 1~5, Pollm'd Sag 871.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	furnmlisms developed relatively independentIy actually common properties; th'~t is, used data structures called ftmctional structures feature structures based unilieathm operation data structures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	formalisms applied field natural language processing and, based formalisms, ~:~ystems machine translation systems developed [l<ol;u, e et l 8gJ.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unification-based formalisms, feature ~trueture (FS) unification fundamental ..~ignifieant operation.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	efficiency systems based ..~uch formalisms, natural language analysis generation systems much depends FS ~lnifieatlon efficiencies.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Tiffs dependency especially crucial lexicon-driven approaches tlPSO[Pollard Sag 861 JPSG[Gunji 871 rich lexieal information phrase structure information described terms FSs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example, spoken Present.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	affiliation: Infi)rmation Science Research 1,aboratory, NTT Basic Research i.aboratories.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	lh'esenl, address: 9 11, Midori cho 3-theme, Musashinoshi, Tokyo 180, Japan.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Japanese analysis system based llPSG[Kogure 891 uses 90% - 98% elapsed time FS unification.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Several FS unificatioa methods proposed IKarttunen 86, l'ereira 85, Wroblewski 871.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	methods uses rooted directed graphs (DGs) represent FSs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	methods take two DGs inputs give unification result DG.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Previous research identified DG copying significant overhead.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Wroblewski claims copying wrong algorithm copies much (over copying) copies soon (early copying).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Ile proposed incremental copy graph unification method avoid copying early copying.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	itowever, problem method unitication result graph consists newly created structures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unnecessary often input snbgraphs used part result graph without modification, sharable parts one input graphs result graph.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Copying sharable parts called redundant copying.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	better method would nfinimize copying sharable varts.	1
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	redundantly copied parts relatively large input graphs common feature paths.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	natural language processing, cases ubiquitous.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"I""or example, unifying FS representing constraints phrase structures FS representing daughter phrase structure, eases occur h'equent, ly."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Kasper's disjunctive feature description unification [Kasper 861, cases occur h'equently unifying definite disjunct's definite parts.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Memory wasted redundant copying causes frequent garbage collection page swapping decrease total system efficiency.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	I)eveloping method avoids memory wastage important.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Pereira's structure sharing FS unification method avoid problem.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method achieves structure sharing importing Bayer Moore approach term structurestl~oyer Moore 721.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method uses data structure consisting skeleton part represent original information environment part represent updated information.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	3'he skeleton part shared one input FSs result FS.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Therefore, Pereira's method needs relatively new structures two input FSs difference size input larger known unification.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	However, Pereira's method create skeleton-enviromnent structures deeply embedded, example, reeursively constructing large phrase structure fl'om parts.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	causes O(log d) graph node access time overhead assembling whole DG skeleton environments number nodes DG.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Avoiding problem method requires special operation merging skeleton-environment structure skeleton structure, prevents structure sharing.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	paper proposes FS unification method allows structure sharing constant m'der node access time.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method achieves structure sharing introducing lazy copying Wroblewski's incremental copy graph unification method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method called lazy i2!cremental copy IFaph unification reel, hod (the LING unifieation method short).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	natural language proeessing system uses deelarative constraint rules terms FSs, FS unification provides constraint-checking structure- building mechanisms.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	advantages system include: (1)rule writers required describe control infimnation eonstraiut application order rule, (12)rule descriptions used iu different processing directions, i.e., analysis general,ion.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	However, advantages describing rules disadvantages applying tt~e lack control information.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example, constructing phrase structure parts (e.g., sentence fi'om subject NP VP), unueeessary computation reduced semantic representation assembled checking constraints grammatical agreements, fail.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	impossible straightforward unification-based formalisms.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	contrast, procedure-based system uses IF-TItEN style rules (i.e., consisting explicit test structure-building operations), possible construct semantic representation (TIIEN par'g) checking agreement (IF part).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	system advantage processing efficiency disadvantage lacking multidirectionality.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	paper, efficiency procedure- based system introduced FS unification-based system.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	is, FS unification method proposed introduces strategy called e_arly failure £inding strategy (the EFF strategy) make FS unification efficient, method, FS unification orders specified explicitly rule wril.ers, controlled learned information tendencies FS constraint application failures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method called strategic ij!~crementaI copy graph unification method (the SING unification method).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	two methods combined single method called strategic lazy ijAcremeatal copy g~raph unification method (the SLING unification method).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Section 2 explains typed feature structures (TFSs) unification them.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Section 3 explains TFS unification method based Wroblewski's method explains problem method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	section also introduces key idea EFF strategy wlfich comes observations method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Section 3 4 introduce LING method SING method, respectively.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Ordinary FSs used unification-based grammar formalisms PAT].{[Shieher 851 arc classified two classes, namely, atomic leSs complex FSs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	atomic FS represented atomic symbol complex FS represented set feature-value pairs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Complex FSs used partially describe objects specifying values certain features attributes described objects.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Complex FSs complex FSs feature values share certain values among features.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ordinary FSs, unification defined using partial ordering based subsumption relationships.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	properties enable flexible descriptions.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"extension allows complex FSs type symbols define lattice structure them, example, [Pollard Sag 8""11."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	type symbol lattice contains greatest type symbol Top, subsumes every type symbol, least type symbol Bottom, subsumed every I.ype symbol.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example type symbol lattice shown Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	1.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	extended complex FS represented type symbol set feature-value pairs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	complex IeSs extended above, atomic FS seen extended complex FS whose type symbol Top greater type symbol Bottom lesser type symbol empty set feature value pairs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Extended complex FSs called typed feature structures (TFSs).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	TFSs denoted feature-value pair matrices rooted directed graphs shown Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	2.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Among structures, unification c'm defined IAP,- Kaci 861 using following order; ATFS tl less equal TFS t2 if:  type symbol tl less equal type syn'bol of/2;  features t2 exists t1 and.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	value TFS less counterpart tl ; coreference relationships t2 also held tl.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Top Sign Syn Head List POS /77 Lexical Phrase Sign NonEmpty Empty V N P ADV Slgn Li.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Lis~ ust NonEmpty Emply Sign Sign I/ / List List 5/ /5 ....	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"U_ Bottom Figure 1: Exainple type symbol lattice --2-- peSymb°10 eaturel TypeSymboll ] ]] feature2 TypeSymbol2 feature3 ?Tag ypeSymbol3 ] ]feature4 TypeSymbol4 L [.feature5 TypeSymbol5 TIeature3 7Tag (a) feature-value matrix notation ""?"" i~ prefix tag TFSs tag token-identical."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	TypeSym bol/~ feo~.,o/ TypeSymboll ~ [.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"TypeSymbol2 4¢"" '~°~'~/.~ypeSymbol3 featury ""X~ature5 TypeSymbol4 4r ""~TypeSymbol5 (b) directed graph notation Figure 2: TFS notations Phrase [sub(at ?X2 SignList ] dtrs CHconst Sign U Syn i'oo syn head ?Xl . ] ubcat NonEmptySignLIst | ['first ]1 ?×3 Lrest ?X2 J j Phrase -dtrs CHconst hdtr LexicalSignsyn Syn -head Head pos P orm Ga subcat NonEmptySignList Sign ,11 yn Synead Head L~,os N] Irest EmptySignkist Phrase ""syn Syn head ?X1 Head Fpos P Lform Ga ] Lsubcat ?X2 Empl.ySignList dtrs CHconst ccltr ?X3 Sign syn iyn head Head _ [pos N hdtr LexicalSign l-syn Syn l F head :x~ 7/ Lsubcat [ NonEinptySignList l l P"""" ~×~ llll Lrest ?X2 JJjJ Figure 3: Example TFS unification Then, unification tl anti t2 defined greatest lower bound meet."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unification example shown Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	3.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	tile directed graph notation, TFS unification corresponds graph mergi ng.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	TFSs convenient describing linguistic information unlfication-based formalisms.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	TFS unification based Wrobtewski's method, DG represented tile NODE ARC structures corresponding TFS feature-value pair respectively, shown Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	4.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	NODE structure slots TYPESYMBOL represent type symbol, ARCS represent set feature-value pairs, GENERATION specify unification process structure created, FORWARD, COPY.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	NODE's GENERATION value equal global value specifying current unit]cation process, structure created current process structure currel~l. characteristics allow nondestructive incremental copy NODE's two different slots, FORWARD COPY, representing forwarding relationships.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	FORWARD slot value represents eternal relationship COPY slot value represents temporary relationship.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	NODE node1 NODE node2 FORWARD value, contents tile node1 ignored tim contents node2 used.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	t{owever, NODE another NODE COPY value, contents COPY value used COPY value cub:rent.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	process finishes, COPY slot values ignored thus original structures destroyed.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unification procedure based method takes input two nodes roots DGs unified.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	procedure incrementally copies nodes ares subgraphs input 1)G node empty ARCS value found.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	procedure first dereferences root nodes input DGs (i.e., follows FORWARD COPY slot values).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	dereferenee result nodes arc identical, procedure finishes returns one dereference result nodes.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Next, procedure calculates meet type symbol.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	meet Bottom, means inconsistency, procedure finishes returns Bottom.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Otherwise, procedure obtains output node meet TYPESYMBOL.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	output node created neither input node current; otherwise output node existing current node.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Next, procedure treats arcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	procedure assumes existence two procedures, namely, SharedArcs ComplementArcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	SharedArcs procedure takes two lists arcs arguments gives two lists arcs contains arcs whose labels exists lists arc label order.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"ComplementArcs procedure takes two lists arcs NODE TYPESYMBOL: <symbol> [ ARCS: <a list ARC structures > FORWARD: ""<aNODEstructure orNIL> / COPY: < NODEstructure Nil, > GENERATION: <an integer> ARC LABEL: <symbol> VALUE: <:a NODEstructure> Figure 4: Data Structures Wroblewski's method Input graph GI Input graph 62 ¢ .......'77 ........ : Sobg,'aphs required copied L ..........................................."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Output graph G3 Figure 5: Incremental copy graph unification figure, type symbols omitted.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	arguments gives one list arcs whose labels unique one input list.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unification procedure first treats arc pairs obtained SharedArcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	procedure applies ,'ecursively arc pair values adds output node every arc label label unification result values unless tmification result Bottom.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Next, procedure treats arcs obtained ComplementArcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	arc value copied arc label copied value added output node.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example, consider case feature first treated root nodes G1 G2 Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	5.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unification procedure applied recursively feature values input nodes.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	node specified feature path <a> fi'om input graph G1 (Gl/<a>) arc label c corresponding node input graph G2 not.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	whole subgraph rooted 6 l/<a c> copied.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	subgraphs modified later.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example, node Y(G3/<o c g>) modified unification result G 1/<a c g> (or G1/<b d>) G2/<b d> feature path <b d> treated.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Incremental Copy Graph Unification PROCEDURE Unify(node1, node2) node1 = Dereference(nodel).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	node2 = Dereferencelnode2).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Eq?(nodel, node2) Return(node1).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE meet = Meet(nodel.typesymbol, node2.typesymbol) Equal?(meet, Bottom) Return(Bottom).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE outnode = GetOutNode(nodel, node2, meet).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	(sharedst, shareds2) = SharedArcs(nodel.arcs, node2.arcs).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	complements1 = ComplementArcs(node|.arcs, node2.arcs).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	complements2 = ComplementArcs(node2.arcs, nodel.arcs).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	(sharedt, shared2) (sharedsl, shareds2) arcnode = Unify(sharedl.value, shared2.value).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Equal?(arcnode, Bottom) ]HEN Return(Bottom).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE AddArc(outnode, sharedl.label, arcnode).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDIF Eq?(outnode, node1) coi'nplements = complement2.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE Eq?(outnode, node2) complements = complementL ELSE complements = Append(complements1, complements2].	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDIF FORALL complement complements newnode = CopyNode(complement.value).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	AddArc(outnode, complement.label, newnode).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Return(outnode).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDIF ENDIE ENDPROCEDURE Figure 6: Incremental copy graph unification procedure problem Wroblewski's method tile whole result DG created using newly created structures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	5, subgraphs result DG surrounded dashed rectangle shared subgraphs input structures G1 G2, Section 4 proposes method t.hat avoids problem, Wroblewski's method first treats arcs labels exist input nodes treats arcs unique labels.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	order related unification failure tendency.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Unification fails treating arcs common labels often treating arcs unique labels.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Finding failure stop computation previously described, thus finding failures first reduces unnecessary computation.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	order strategy generalized EFF applied ordering arcs common labels.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Section 5, method uses generalized strategy proposed.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Wroblewski's method, copying unique label arc values whole order treat cases like ]Pig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	5 disables structure sharing, ttowever, whole copying necessary lazy evaluation method used.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method, possible delay copying node either contents need change (e.g., node G3/Ka c !7>) found arc (sequence) node t, hat needs copied (e.g., node X G3/<a c> Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	5 due change node G3/<a c g>).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	achieve this, I, LING unification method, uses copy dependency information, developed.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	LING unification procedure uses revised CopyNode procedure copy structures immediately.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	revised procedure uses newly introduced slot COPY-DEPENDENCY.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	slot pairs consisting nodes arcs value.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	revised CopyNode procedure takes inputs node copied node arc arc node value node2 immediate ancestor node (i.e., arc's initial node), following (set Fig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"7): (1) nodel ', dereference result node/, current, CopyNode returns node l"" indicate ancestor node node2 must coiffed immediately; (2)otherwise, CopyArcs applied node1"" returns ,~;everal arc copies, CopyNode creates new copy node."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"adds arc copies arcs node/' copied new node, returns new node; (3) otherwise, CopyNode adds pair consisting ancestor node node2 arcl COPY- DEPENDENCY slot node 1"" returns Nil_."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	,',:opyArcs applies CopyNode arc value node l' new ancestor node returns set new arcs non-Nil_ CopyNode results.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	new copy node needed later, LING unification procedure actually copy structures using COPY-DEPENDENCY slot value node (in GetOutNode procedure lJ'ig.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	6).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	substitutes arcs newly copied nodes existing arcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	is, antecedent nodes COPY-DEPENDENCY values also copied.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	explanation, COPY-DEPENDENCY COPY slots used sake simplicity.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	]lowever, method achieved COPY slot node non-NIL COPY-I)EPENDENCY COPY values simultaneously.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	data COPY-DEPENDENCY slot I;emporary discarded extensive process analyzing sentence, ttowever, result incompleteness partial analysis structure test.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Moreover, data accessed constant order time relative number DG nodes need reconstructed method use data structure consisl, ing ,';keleton environments Pereira's method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	efficiency LING unification method depends proportion newly created structures unification result structures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Two worst eases considered: (t) arcs whose labels unique input node witlh respect other, procedure LING unification method behaves way procedure Wroblewski's method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	(2) worst eases, unique label arcs result structures newly created, method CopyNode PROCEDURE CopyNode(node, arc, ancestor) node = Dereference(node).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Current?(node) Return(node).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE NotEmpty?(newarcs = CopyArcs(node)) newnode = Create(node.typesymbol).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	node.copy = newnode.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	arc node.arcs NotNIL?(newarc = FindArc(arc.label, newarcs)) AddArc(newnode, newarc.label, newarc.value}.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE AddArc(newnode, arc.label, arc.value).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDIF Returo(newnode).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ELSE node.copy-dependency = node.copy-dependency U {Cons(ancestor, arc)}.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Return(Nil_).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied(node) newarcs = O- arc node.arcs newnode = CopyNode(arc.value, arc, node).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	NotNIL?(newnode) newarc = CreateArc(arc.label, newnode).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	newarcs = {newarc} U newarcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDIF Return(newarcs).	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	ENDPROCEDURE Figure 7: revised CopyNode procedure disadvantage treating copy dependency information.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	However, two cases rare.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Usually, number features two input structures relatively small sizes two input structures often different.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	"example, Kasper's disjunctive feature description unification, definite part [""S larger disjunet definite part t""S."	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Method system FS unification applied, features whose values fail relatively often unification values features whose values fail often.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example, Japanese sentence analysis, unification features conjugation forms, case markers, semantic selectional restrictions tends fail unification features semantic representations fail.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	cases, application EFF strategy, is, treating features tending fall unification first, reduces unnecessary computation unification finally fails.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	example, unification features case markers fail, treating features first avoids treating features senmntic representations.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	SING unification method uses failure tendency infornmtion.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	unification failure tendencies depend systems analysis systems generation systems.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Unlike analysis case, unification features semantic representations tends fail.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	method, theretbre, failure tendency information acquired learning process.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	is, SING unification method applied analysis system uses failure tendency information acquired learning analysis process.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	learning process, FS unification applied, feature treatment orders randomized sake random extraction.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	TFS unification, failure tendency information recorded terms triplet consisting greatest lower bound type symbol input TFSs' type symbols, feature success/failure flag.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	type symbol 'rFS represents salient information whole TFS.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	using learned failure tendency information, feature value unification applied order first treats features greatest tendency fail.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	achieved sorting procedure common label arc pairs attached meet type symbol.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	arc pairs obtained SharedArcs procedure sorted treating arcs.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	efficiency SING unification method depends following factors: (1) overall FS unification failure rate process: extreme cases, Go unification failure occurs, method advantages except overhead feature unification order sorting.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	However, cases occur practice.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	(2) Number features FSs have: FS small number features, efficiency gain SING unification method small.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	(3) Unevenness FS unification failure tendency: extreme cases, every feature unification failure tendency, method advantage.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	However, cases occur rare, example, many cases natural language analysis, FS unification failures occur treating limited kinds features related grammatical agreement number and/or person agreement semantic selectional constraints.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	cases, SING unification method obtains efl]ciency gains.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	factors examined inspecting failure tendency information, efficiency gain SING method predicted.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Moreover, possible type symbol select whether apply feature unification order sorting not.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	strategic lazy incremental copy graph (SLING) unification method combines two incremental copy graph unification methods: lazy incremental copy graph (LING) unification method strategic incremental copy graph (SING) unification method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	LING unification method achieves structure sharing without O(log d) data access overhead Pereira's method.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Structure sharing avoids memory wastage'.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Furthermore, structure sharing increases portion token identical substructures FSs makes efficient keep unification results substructures FSs reuse them.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	reduces repeated calculation substructures.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	SING unification method introduces concept feature unification strategy.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	'the method treats features tending fail unification first.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	Thus, efficiency gain fi'om method high overall FS unification failure rate application process high.	0
PM also choose among different unification algorithms designed to: * carefully control minimize amount copying needed non-deterministic parsing schemata (Wroblewski, 1987) (Kogure, 1990);	combined method Inakes FS unification efficient also reduces garbage collection page swapping occurrences avoiding memory wastage, thus increasing total efficiency li'S unification-based natural language processing systems aa analysis generation systems based IlI'SG.	0
